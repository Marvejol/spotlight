<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaic Fuego - The Agora</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=League+Spartan:wght@700&display=swap" rel="stylesheet">
    
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        canvas { display: block; }
        
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 100; padding: 20px; color: black; }
        .interactive { pointer-events: auto; }
        
        /* Agora Input Panel */
        #agora-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); padding: 20px 30px; border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 15px;
            width: 400px; text-align: center;
        }
        
        .input-group { display: flex; flex-direction: column; gap: 5px; text-align: left; }
        .input-group label { font-size: 11px; font-weight: bold; text-transform: uppercase; color: #555; }
        .input-row { display: flex; gap: 10px; }
        
        input[type="text"] {
            border: 1px solid #ddd; padding: 10px; border-radius: 8px; font-size: 14px;
            width: 100%; box-sizing: border-box; background: #fafafa;
        }
        input[type="text"]:focus { outline: none; border-color: #2196F3; background: #fff; }
        
        .btn {
            background: #212121; color: white; border: none; padding: 12px 20px; 
            border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 13px;
            text-transform: uppercase; letter-spacing: 1px; transition: transform 0.1s, background 0.2s;
        }
        .btn:hover { background: #000; }
        .btn:active { transform: scale(0.98); }
        
        #zoomToggle { position: absolute; top: 20px; right: 20px; border-radius: 20px; font-size: 11px; padding: 8px 16px;}

        /* --- UPDATED CARVED TEXT SYSTEM --- */
        #labels-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            pointer-events: none; overflow: hidden; z-index: 50;
        }
        
        /* Base container tracks the 3D blob position */
        .blob-label-container {
            position: absolute; top: 0; left: 0;
            width: 0; height: 0;
            display: flex; align-items: center; justify-content: center;
            will-change: transform;
            user-select: none;
        }

        /* The refined, carved text matching feedback */
        .blob-label {
            position: absolute;
            font-family: "League Spartan", sans-serif;
            font-weight: 700; /* Lighter weight requested */
            line-height: 1;
            white-space: nowrap;
            letter-spacing: -0.06em; /* Very little space between letters */
            text-transform: uppercase; /* All caps */
            text-align: center;
            z-index: 10;
            
            /* The 'carved' look placeholders. The dynamic colors are applied in JS. */
            /* This shadow structure creates the debossed effect (dark top/left, light bottom/right) */
            text-shadow: -1px -1px 0px rgba(0,0,0,0.3), 1px 1px 1px rgba(255,255,255,0.4); 
        }

        /* Small adjustment for topics */
        .blob-label-container.is-topic .blob-label {
            letter-spacing: -0.07em; /* Even tighter for main topics */
        }
    </style>
</head>
<body>

    <div id="labels-layer"></div>

    <div id="ui-layer">
        <div id="agora-panel" class="interactive">
            <div style="font-weight: 800; font-size: 18px; letter-spacing: -0.5px;">THE AGORA</div>
            <div style="font-size: 12px; color: #666; margin-top: -10px;">Map the Zeitgeist. What connections do you see?</div>
            
            <div class="input-group">
                <label>The Topic</label>
                <input type="text" id="input-topic" placeholder="e.g., Artificial Intelligence" autocomplete="off">
            </div>
            
            <div class="input-group">
                <label>3 Instinctive Associations</label>
                <div class="input-row">
                    <input type="text" id="input-word1" placeholder="Word 1" autocomplete="off">
                    <input type="text" id="input-word2" placeholder="Word 2" autocomplete="off">
                    <input type="text" id="input-word3" placeholder="Word 3" autocomplete="off">
                </div>
            </div>
            
            <button class="btn" id="btn-submit">Add to Map</button>
        </div>

        <button class="btn interactive" id="zoomToggle">Toggle View</button>
    </div>
    
    <div id="container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec2 vUv;
        uniform vec3 uColor;
        uniform float uSeed;
        uniform float uTime;
        uniform float uIntensity;

        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

        void main() {
            vec2 pos = vUv - 0.5;
            float dist = length(pos);
            float angle = atan(pos.y, pos.x);

            float spikeAmp = 0.03 + (uIntensity * 0.05); 
            float spikes = sin(angle * (8.0 + mod(uSeed, 4.0)) + uSeed + uTime * uIntensity) * spikeAmp;
            float burst = sin(angle * (12.0 + mod(uSeed, 8.0)) - uSeed) * 0.015;
            
            float edgeDist = 0.41 + spikes + burst;
            float shapeMask = 1.0 - smoothstep(edgeDist, edgeDist + 0.01, dist);
            
            vec2 screenCoord = gl_FragCoord.xy;
            float staticGrain = (random(screenCoord * 0.5) - 0.5) * 0.14;
            
            vec3 baseColor = mix(uColor, vec3(1.0, 1.0, 1.0), uIntensity * 0.6);
            vec3 color = mix(baseColor * 1.15, baseColor * 0.85, dist * 1.5) + staticGrain;

            gl_FragColor = vec4(color, shapeMask);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // 0. GLOBAL MEASURING TOOLS for Dynamic Font Scaling
        const measuringCanvas = document.createElement('canvas');
        const measuringContext = measuringCanvas.getContext('2d');
        const baseMeasuringFontSize = 100;

        const wordMap = new Map();
        let globalIdCounter = 0;

        // 1. BLOB CLASS
        class Blob {
            constructor(word, x, y, isTopic, scene, geo, matBase, labelContainer) {
                this.id = globalIdCounter++; 
                this.word = word.trim().toLowerCase(); 
                this.isTopic = isTopic;
                
                this.pos = new THREE.Vector2(x, y);
                this.vel = new THREE.Vector2(0, 0); 
                
                this.baseRadius = isTopic ? 20 : 12;
                this.tokens = 1; 
                this.targetRadius = this.baseRadius;
                this.radius = 0.1; 
                this.mass = this.radius * this.radius;
                
                // WebGL Setup - Generate dynamic color
                this.material = matBase.clone();
                this.hue = Math.random();
                
                // Set the 3D blob color (medium base brightness)
                this.material.uniforms.uColor.value.setHSL(this.hue, 0.6, 0.6);
                this.material.uniforms.uSeed.value = Math.random() * 100.0;
                this.material.uniforms.uTime = { value: 0 };
                this.material.uniforms.uIntensity = { value: 0 };

                this.mesh = new THREE.Mesh(geo, this.material);
                this.mesh.userData.parent = this;
                scene.add(this.mesh);
                
                // --- Calculate 'Carved' Colors based on Hue ---
                // The face of the carved text is slightly darker than the blob surface
                const faceColor = `hsl(${this.hue * 360}, 60%, 45%)`; 
                // The upper-left 'inner shadow' groove is quite dark
                const innerShadowColor = `hsl(${this.hue * 360}, 60%, 20%)`; 
                // The bottom-right 'carved edge' highlight is very bright
                const edgeHighlightColor = `hsl(${this.hue * 360}, 60%, 80%)`;

                // --- Perform text measuring once upon creation ---
                this.wordUpper = this.word.toUpperCase();
                // Measure the text width at a large base size (100px)
                // Need to ensure font is loaded before measuring (happens in App init wrapper)
                measuringContext.font = `700 ${baseMeasuringFontSize}px 'League Spartan'`;
                this.textWidthAt100 = measuringContext.measureText(this.wordUpper).width;

                // DOM Setup using App's static factory method
                this.labelEl = App.createLabelDOM(this.wordUpper, this.isTopic, faceColor, innerShadowColor, edgeHighlightColor);
                labelContainer.appendChild(this.labelEl);
                
                this.recalcTarget();
            }
            
            addToken() {
                this.tokens++;
                this.recalcTarget();
            }

            recalcTarget() {
                this.targetRadius = this.baseRadius * Math.sqrt(this.tokens * 0.8);
                this.material.uniforms.uIntensity.value = Math.min(this.tokens / 20.0, 1.0);
            }

            update(fric, settle, vW, vH, time) {
                this.radius += (this.targetRadius - this.radius) * settle;
                this.mass = this.radius * this.radius;
                
                this.vel.x -= this.pos.x * 0.001;
                this.vel.y -= this.pos.y * 0.001;

                this.pos.add(this.vel); 
                this.vel.multiplyScalar(fric);
                this.material.uniforms.uTime.value = time;
            }

            draw(camera, currentZoom) { 
                const d = this.radius * 2.6; 
                this.mesh.scale.set(d, d, 1); 
                this.mesh.mesh.position.set(this.pos.x, this.pos.y, 0); 
                
                const vector = new THREE.Vector3(this.pos.x, this.pos.y, 0);
                vector.project(camera); 
                
                const screenX = (vector.x * .5 + .5) * window.innerWidth;
                const screenY = -(vector.y * .5 - .5) * window.innerHeight;
                
                // Project world radius to screen pixel radius
                const pixelsPerUnit = window.innerHeight / currentZoom;
                const pixelRadius = this.radius * pixelsPerUnit;
                const pixelDiameter = pixelRadius * 2;
                
                // --- DYNAMIC FONT SCALING (Always stay inside) ---
                
                // Calculate max allowable dimensions (diameter minus some safe margin)
                const safeMargin = this.isTopic ? 0.8 : 0.75; 
                const maxAllowedWidth = pixelDiameter * safeMargin;
                const maxAllowedHeight = pixelDiameter * safeMargin;

                // Base scale target (target height)
                const targetHeight = maxAllowedHeight * 0.65; // Font size approx target height

                // Width constraint calculation:
                // fs_width = (maxAllowedWidth / textWidthAt100) * 100
                const fsWidth = (maxAllowedWidth / this.textWidthAt100) * baseMeasuringFontSize;

                // Dynamic Font Size is the smaller of the constraints
                const dynamicFontSize = Math.min(targetHeight, fsWidth);
                
                this.labelEl.style.transform = `translate(${screenX}px, ${screenY}px)`;
                this.labelEl.style.fontSize = `${dynamicFontSize}px`;
            }
        }

        // 2. MAIN APP
        class App {
            constructor() {
                this.config = { 
                    friction: 0.14, 
                    repulsion: 0.65, 
                    settleSpeed: 0.05, 
                    zoomIn: 400, 
                    zoomOut: 1000 
                };
                
                this.blobs = []; 
                this.targetZoom = this.config.zoomIn; 
                this.currentZoom = this.config.zoomIn;
                this.cameraOffset = new THREE.Vector2(0, 0); 
                this.isPanning = false; 

                this.initScene(); 
                this.bindEvents(); 
                this.animate();
            }

            // Static factory: clean, single-layer carved text DOM
            static createLabelDOM(wordString, isTopic, faceColor, shadowColor, highlightColor) {
                const container = document.createElement('div');
                container.className = 'blob-label-container';
                if(isTopic) container.classList.add('is-topic');

                const text = document.createElement('div');
                text.className = 'blob-label';
                text.innerText = wordString;
                
                // Set Dynamic Carved Colors
                text.style.color = faceColor;
                // Complex text-shadow for debossed 'carved' look: 
                // -2px -2px shadow inside top-left groove
                // 1px 1px highlight outside bottom-right carved edge
                text.style.textShadow = `-2px -2px 1px ${shadowColor}, 1px 1px 1px ${highlightColor}`;

                container.appendChild(text);
                return container;
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera();
                this.camera.position.z = 10;
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                this.labelContainer = document.getElementById('labels-layer');
                
                this.baseGeo = new THREE.PlaneGeometry(1, 1);
                this.baseMat = new THREE.ShaderMaterial({
                    uniforms: { uColor: { value: new THREE.Color() }, uSeed: { value: 0 }, uTime: { value: 0 }, uIntensity: { value: 0 } },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    transparent: true, depthTest: false
                });
            }

            addNode(wordString, isTopic) {
                const cleanWord = wordString.trim().toLowerCase();
                if (!cleanWord) return;

                if (wordMap.has(cleanWord)) {
                    const existingBlob = wordMap.get(cleanWord);
                    existingBlob.addToken();
                    existingBlob.vel.y += 2;
                } else {
                    const spawnRadius = 50;
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * spawnRadius;
                    const y = Math.sin(angle) * spawnRadius;
                    
                    const blob = new Blob(
                        cleanWord, x, y, isTopic, 
                        this.scene, this.baseGeo, this.baseMat, this.labelContainer
                    );
                    
                    this.blobs.push(blob);
                    wordMap.set(cleanWord, blob);
                }
            }

            handleSubmission() {
                const topicInput = document.getElementById('input-topic');
                const w1 = document.getElementById('input-word1');
                const w2 = document.getElementById('input-word2');
                const w3 = document.getElementById('input-word3');

                if(!topicInput.value) { alert("Please enter a topic."); return; }

                this.addNode(topicInput.value, true); 
                this.addNode(w1.value, false);
                this.addNode(w2.value, false);
                this.addNode(w3.value, false);

                topicInput.value = ''; w1.value = ''; w2.value = ''; w3.value = '';
                topicInput.focus();
            }

            bindEvents() {
                document.getElementById('zoomToggle').onclick = () => {
                    this.targetZoom = (this.targetZoom === this.config.zoomIn) ? this.config.zoomOut : this.config.zoomIn;
                    if(this.targetZoom === this.config.zoomIn) this.cameraOffset.set(0,0);
                };
                
                document.getElementById('btn-submit').onclick = () => this.handleSubmission();
                
                document.getElementById('agora-panel').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleSubmission();
                });

                window.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.interactive')) return;
                    if (this.targetZoom === this.config.zoomOut) {
                        this.isPanning = true; this.prevMouse = { x: e.clientX, y: e.clientY };
                    }
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (this.isPanning && this.targetZoom === this.config.zoomOut) {
                        const scalar = this.currentZoom / window.innerHeight;
                        this.cameraOffset.x -= (e.clientX - this.prevMouse.x) * scalar;
                        this.cameraOffset.y += (e.clientY - this.prevMouse.y) * scalar;
                        this.prevMouse = { x: e.clientX, y: e.clientY };
                    }
                });
                
                window.addEventListener('mouseup', () => this.isPanning = false);
                
                window.addEventListener('resize', () => {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            resolvePhysics() {
                for (let i = 0; i < this.blobs.length; i++) {
                    const b1 = this.blobs[i];
                    for (let j = i + 1; j < this.blobs.length; j++) {
                        const b2 = this.blobs[j];
                        const dx = b2.pos.x - b1.pos.x;
                        const dy = b2.pos.y - b1.pos.y;
                        const d2 = dx*dx + dy*dy;
                        const minDist = b1.radius + b2.radius;
                        
                        if (d2 < minDist * minDist) {
                            const d = Math.sqrt(d2) || 0.1;
                            const overlap = (minDist - d) * this.config.repulsion;
                            const nx = dx/d, ny = dy/d, tm = b1.mass + b2.mass;
                            
                            b1.vel.x -= nx * overlap * (b2.mass / tm); 
                            b1.vel.y -= ny * overlap * (b2.mass / tm);
                            b2.vel.x += nx * overlap * (b1.mass / tm); 
                            b2.vel.y += ny * overlap * (b1.mass / tm);
                        }
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = performance.now() * 0.001;
                this.currentZoom += (this.targetZoom - this.currentZoom) * 0.08;
                const aspect = window.innerWidth / window.innerHeight;
                
                const vW = this.currentZoom * aspect;
                const vH = this.currentZoom;
                
                this.camera.left = -vW/2 + this.cameraOffset.x; 
                this.camera.right = vW/2 + this.cameraOffset.x;
                this.camera.top = vH/2 + this.cameraOffset.y; 
                this.camera.bottom = -vH/2 + this.cameraOffset.y;
                this.camera.updateProjectionMatrix();

                this.blobs.forEach(b => b.update(this.config.friction, this.config.settleSpeed, vW, vH, time));
                this.resolvePhysics();
                
                this.blobs.forEach(b => b.draw(this.camera, this.currentZoom));

                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // --- CRITICAL INITIALIZATION ---
        // We MUST wait for the custom font to load before measuring text width,
        // otherwise measuringContext.measureText will measure default browser fonts.
        document.fonts.ready.then(() => {
            console.log("League Spartan Loaded. Initializing App.");
            window.app = new App();
        });
    </script>
</body>
</html>
