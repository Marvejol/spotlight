<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Z-Extruder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; }
        canvas { display: block; }
    </style>
</head>
<body class="text-slate-200 font-sans">

    <div class="fixed top-6 left-6 z-10 pointer-events-none">
        <h1 class="text-xl font-bold tracking-tighter uppercase opacity-80">Voxel Grid</h1>
        <p class="text-sm font-mono opacity-50">Credits: <span id="credit-count" class="text-emerald-400">50</span></p>
    </div>

    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // State
        let credits = 50;
        const gridRes = 20; // 20x20 grid
        const cubes = [];

        // Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 20, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('container').appendChild(renderer.domElement);

        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Grid Generation
        const geometry = new THREE.BoxGeometry(0.9, 1, 0.9); // Slight gap between cubes
        for (let x = 0; x < gridRes; x++) {
            for (let z = 0; z < gridRes; z++) {
                const material = new THREE.MeshStandardMaterial({ color: 0x334155 });
                const cube = new THREE.Mesh(geometry, material);
                
                // Offset to center the grid
                cube.position.set(x - gridRes/2, 0, z - gridRes/2);
                scene.add(cube);
                cubes.push(cube);
            }
        }

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (event) => {
            if (credits <= 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);

            if (intersects.length > 0) {
                const clickedCube = intersects[0].object;
                
                // Logic: Move Up and Scale Z (making it a taller parallelepiped)
                clickedCube.scale.y += 2;
                clickedCube.position.y += 1; // Keep the base roughly in place
                clickedCube.material.color.set(0x10b981); // Flash emerald on click
                
                setTimeout(() => {
                    clickedCube.material.color.set(0x64748b);
                }, 200);

                credits--;
                document.getElementById('credit-count').innerText = credits;
            }
        });

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
