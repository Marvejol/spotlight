<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grainy Viscous Blobs</title>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000000; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec2 vUv;
        uniform float uTime;
        uniform vec3 uColor;
        uniform float uGrainScale;

        // --- Simplex Noise functions (standard GLSL noise implementation) ---
        vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
        float snoise(vec2 v){
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            vec2 i  = floor(v + dot(v, C.yy) );
            vec2 x0 = v - i + dot(i, C.xx);
            vec2 i1;
            i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec4 x12 = x0.xyxy + C.xxzz;
            x12.xy -= i1;
            i = mod(i, 289.0);
            vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
            vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
            m = m*m ;
            m = m*m ;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
            vec3 g;
            g.x  = a0.x  * x0.x  + h.x  * x0.y;
            g.yz = a0.yz * x12.xz + h.yz * x12.yw;
            return 130.0 * dot(m, g);
        }

        // Simple hash for grain
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
            vec2 center = vec2(0.5, 0.5);
            vec2 pos = vUv - center;
            float dist = length(pos);
            float angle = atan(pos.y, pos.x);

            // --- Viscous Wobble ---
            // Use noise based on angle and time to distort the distance field
            // This makes the border wavy instead of a perfect circle
            float wobble = snoise(vec2(angle * 3.0, uTime * 0.3)) * 0.08; // Adjust 3.0 for wave frequency, 0.08 for wave depth
            float perturbedDist = dist + wobble;
            
            // Define soft edge based on distorted distance
            // Smoothstep creates the "middle ground" borderâ€”not rigid, not totally blurry
            float alpha = 1.0 - smoothstep(0.35, 0.48, perturbedDist);

            // --- Grainy Texture ---
            // Calculate high frequency noise specifically for grain
            float noiseVal = snoise(vUv * uGrainScale + uTime * 0.5);
            // Mix the noise into the color to create gradient patches
            vec3 mixedColor = mix(uColor * 0.7, uColor * 1.3, noiseVal * 0.5 + 0.5);
            
            // Add fine film grain on top
            float fineGrain = random(vUv * uTime) * 0.15;
            mixedColor += fineGrain;

            gl_FragColor = vec4(mixedColor, alpha * 0.85); // 0.85 overall opacity
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Configuration ---
        const config = {
            initialCount: 250,
            baseRadius: 50,
            growthRate: 2.0,
            growthChance: 0.08,
            maxRadius: 300,
            friction: 0.92,
            repulsionStrength: 0.3,
            grainScale: 3.0 // Controls how "chunky" the internal gradients are
        };

        let blobs = [];
        let width = window.innerWidth;
        let height = window.innerHeight;
        let globalTime = 0;

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        const camera = new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, 1, 1000);
        camera.position.z = 10;
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false }); // Antialias off for grittier look
        renderer.setSize(width, height);
        document.getElementById('container').appendChild(renderer.domElement);

        // Get shader code from DOM
        const vShader = document.getElementById('vertexshader').textContent;
        const fShader = document.getElementById('fragmentshader').textContent;

        // common geometry used by all blobs
        const planeGeometry = new THREE.PlaneGeometry(1, 1);

        // --- Blob Class ---
        class Blob {
            constructor(x, y, radius, hue) {
                this.pos = new THREE.Vector2(x, y);
                this.vel = new THREE.Vector2(0, 0);
                this.radius = radius;
                this.targetRadius = radius;
                this.mass = radius * radius;

                const color = new THREE.Color(`hsl(${hue}, 75%, 55%)`);
                
                // USE SHADER MATERIAL INSTEAD OF BASIC MATERIAL
                this.uniforms = {
                    uTime: { value: 0.0 },
                    uColor: { value: color },
                    uGrainScale: { value: config.grainScale }
                };

                const material = new THREE.ShaderMaterial({
                    uniforms: this.uniforms,
                    vertexShader: vShader,
                    fragmentShader: fShader,
                    transparent: true,
                    depthTest: false,
                    blending: THREE.NormalBlending
                });

                this.mesh = new THREE.Mesh(planeGeometry, material);
                scene.add(this.mesh);
                this.updateVisuals(0);
            }

            grow() {
                const addedArea = Math.random() * 15000;
                const currentArea = Math.PI * this.targetRadius * this.targetRadius;
                this.targetRadius = Math.sqrt((currentArea + addedArea) / Math.PI);
                this.targetRadius = Math.min(this.targetRadius, config.maxRadius);
            }

            updatePhysics() {
                this.radius += (this.targetRadius - this.radius) * 0.06;
                this.mass = this.radius * this.radius;
                this.pos.add(this.vel);
                this.vel.multiplyScalar(config.friction);
                // Keep near center
                this.vel.add(this.pos.clone().multiplyScalar(-0.0005));
            }

            updateVisuals(time) {
                // Update shader time uniform for wobble animation
                this.uniforms.uTime.value = time;
                // Scale mesh (multiplied by 2.2 to account for shader padding)
                const d = this.radius * 2.2;
                this.mesh.scale.set(d, d, 1);
                this.mesh.position.set(this.pos.x, this.pos.y, 0);
            }
        }


        // --- Initialization & Physics (Same as before) ---
        function init() {
            const cols = Math.sqrt(config.initialCount * (width/height));
            const rows = config.initialCount / cols;
            const cellW = width / cols;
            const cellH = height / rows;

            for(let i = 0; i < cols; i++) {
                for(let j = 0; j < rows; j++) {
                    const x = (i * cellW) - width/2 + (Math.random() * cellW * 0.5);
                    const y = (j * cellH) - height/2 + (Math.random() * cellH * 0.5);
                    // Limit hue range slightly to avoid "sludge" colors
                    const hue = Math.random() * 340; 
                    blobs.push(new Blob(x, y, config.baseRadius, hue));
                }
            }
        }
        init();

        function resolveCollisions() {
            for (let i = 0; i < blobs.length; i++) {
                for (let j = i + 1; j < blobs.length; j++) {
                    const b1 = blobs[i];
                    const b2 = blobs[j];
                    const dx = b2.pos.x - b1.pos.x;
                    const dy = b2.pos.y - b1.pos.y;
                    const distanceSq = dx * dx + dy * dy;
                    // Physics still uses circular collision for stability
                    const minDist = b1.radius + b2.radius;

                    if (distanceSq < minDist * minDist) {
                        const distance = Math.sqrt(distanceSq) || 0.01;
                        const overlap = minDist - distance;
                        const nx = dx / distance;
                        const ny = dy / distance;
                        const totalMass = b1.mass + b2.mass;
                        const force = overlap * config.repulsionStrength;
                        b1.vel.x -= nx * force * (b2.mass / totalMass);
                        b1.vel.y -= ny * force * (b2.mass / totalMass);
                        b2.vel.x += nx * force * (b1.mass / totalMass);
                        b2.vel.y += ny * force * (b1.mass / totalMass);
                    }
                }
            }
        }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            globalTime += 0.02;

            if (Math.random() < config.growthChance) {
                blobs[Math.floor(Math.random() * blobs.length)].grow();
            }

            blobs.forEach(b => b.updatePhysics());
            for(let i = 0; i < 3; i++) resolveCollisions();
            
            // Pass global time to visual update
            blobs.forEach(b => b.updateVisuals(globalTime));

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            width = window.innerWidth;
            height = window.innerHeight;
            camera.left = width / -2;
            camera.right = width / 2;
            camera.top = height / 2;
            camera.bottom = height / -2;
            camera.updateProjectionMatrix();
            renderer.setSize(width, height);
        });

    </script>
</body>
</html>
