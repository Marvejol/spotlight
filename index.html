<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaic Fuego - The Agora</title>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        canvas { display: block; }
        
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 100; padding: 20px; color: black; }
        .interactive { pointer-events: auto; }
        
        /* Agora Input Panel */
        #agora-panel {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95); padding: 20px 30px; border-radius: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 15px;
            width: 400px; text-align: center;
        }
        
        .input-group { display: flex; flex-direction: column; gap: 5px; text-align: left; }
        .input-group label { font-size: 11px; font-weight: bold; text-transform: uppercase; color: #555; }
        .input-row { display: flex; gap: 10px; }
        
        input[type="text"] {
            border: 1px solid #ddd; padding: 10px; border-radius: 8px; font-size: 14px;
            width: 100%; box-sizing: border-box; background: #fafafa;
        }
        input[type="text"]:focus { outline: none; border-color: #2196F3; background: #fff; }
        
        .btn {
            background: #212121; color: white; border: none; padding: 12px 20px; 
            border-radius: 8px; cursor: pointer; font-weight: bold; font-size: 13px;
            text-transform: uppercase; letter-spacing: 1px; transition: transform 0.1s, background 0.2s;
        }
        .btn:hover { background: #000; }
        .btn:active { transform: scale(0.98); }
        
        #zoomToggle { position: absolute; top: 20px; right: 20px; border-radius: 20px; font-size: 11px; padding: 8px 16px;}

        /* Text Label Overlay System */
        #labels-layer {
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh;
            pointer-events: none; overflow: hidden; z-index: 50;
        }
        
        .blob-label {
            position: absolute; top: 0; left: 0;
            color: #fff; font-weight: 800; text-align: center;
            text-shadow: 0px 2px 10px rgba(0,0,0,0.6), 0px 0px 4px rgba(0,0,0,0.8);
            transform: translate(-50%, -50%); /* Center on the coordinate */
            transition: font-size 0.2s ease-out;
            will-change: transform;
            user-select: none;
        }
        
        /* Differentiate Topics from generic words visually */
        .blob-label.is-topic { text-transform: uppercase; color: #ffebee; letter-spacing: 1px; }
    </style>
</head>
<body>

    <div id="labels-layer"></div>

    <div id="ui-layer">
        <div id="agora-panel" class="interactive">
            <div style="font-weight: 800; font-size: 18px; letter-spacing: -0.5px;">THE AGORA</div>
            <div style="font-size: 12px; color: #666; margin-top: -10px;">Map the Zeitgeist. What connections do you see?</div>
            
            <div class="input-group">
                <label>The Topic</label>
                <input type="text" id="input-topic" placeholder="e.g., Artificial Intelligence" autocomplete="off">
            </div>
            
            <div class="input-group">
                <label>3 Instinctive Associations</label>
                <div class="input-row">
                    <input type="text" id="input-word1" placeholder="Word 1" autocomplete="off">
                    <input type="text" id="input-word2" placeholder="Word 2" autocomplete="off">
                    <input type="text" id="input-word3" placeholder="Word 3" autocomplete="off">
                </div>
            </div>
            
            <button class="btn" id="btn-submit">Add to Map</button>
        </div>

        <button class="btn interactive" id="zoomToggle">Toggle View</button>
    </div>
    
    <div id="container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec2 vUv;
        uniform vec3 uColor;
        uniform float uSeed;
        uniform float uTime;
        uniform float uIntensity;

        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

        void main() {
            vec2 pos = vUv - 0.5;
            float dist = length(pos);
            float angle = atan(pos.y, pos.x);

            float spikeAmp = 0.03 + (uIntensity * 0.05); 
            float spikes = sin(angle * (8.0 + mod(uSeed, 4.0)) + uSeed + uTime * uIntensity) * spikeAmp;
            float burst = sin(angle * (12.0 + mod(uSeed, 8.0)) - uSeed) * 0.015;
            
            float edgeDist = 0.41 + spikes + burst;
            float shapeMask = 1.0 - smoothstep(edgeDist, edgeDist + 0.01, dist);
            
            vec2 screenCoord = gl_FragCoord.xy;
            float staticGrain = (random(screenCoord * 0.5) - 0.5) * 0.14;
            
            vec3 baseColor = mix(uColor, vec3(1.0, 1.0, 1.0), uIntensity * 0.6);
            vec3 color = mix(baseColor * 1.15, baseColor * 0.85, dist * 1.5) + staticGrain;

            gl_FragColor = vec4(color, shapeMask);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Modular App State
        const wordMap = new Map();
        let globalIdCounter = 0;

        // 1. BLOB CLASS
        class Blob {
            constructor(word, x, y, isTopic, scene, geo, matBase, labelContainer) {
                this.id = globalIdCounter++; 
                this.word = word; 
                this.isTopic = isTopic;
                
                this.pos = new THREE.Vector2(x, y);
                this.vel = new THREE.Vector2(0, 0); 
                
                // Topics start slightly larger
                this.baseRadius = isTopic ? 20 : 12;
                this.tokens = 1; 
                this.targetRadius = this.baseRadius;
                this.radius = 0.1; // Start tiny for pop-in animation
                this.mass = this.radius * this.radius;
                
                // WebGL Mesh Setup
                this.material = matBase.clone();
                this.material.uniforms.uColor.value.setHSL(Math.random(), 0.7, 0.5);
                this.material.uniforms.uSeed.value = Math.random() * 100.0;
                this.material.uniforms.uTime = { value: 0 };
                this.material.uniforms.uIntensity = { value: 0 };

                this.mesh = new THREE.Mesh(geo, this.material);
                this.mesh.userData.parent = this;
                scene.add(this.mesh);
                
                // DOM Label Setup
                this.labelEl = document.createElement('div');
                this.labelEl.className = 'blob-label';
                if(isTopic) this.labelEl.classList.add('is-topic');
                this.labelEl.innerText = this.word;
                labelContainer.appendChild(this.labelEl);
                
                this.recalcTarget();
            }
            
            addToken() {
                this.tokens++;
                this.recalcTarget();
            }

            recalcTarget() {
                // Square Root Law for diminishing sizing
                this.targetRadius = this.baseRadius * Math.sqrt(this.tokens * 0.8);
                this.material.uniforms.uIntensity.value = Math.min(this.tokens / 20.0, 1.0);
                
                // Update font size based on tokens
                const fontSize = this.isTopic ? 
                    Math.min(14 + (this.tokens * 1.5), 36) : 
                    Math.min(11 + (this.tokens * 1.2), 24);
                this.labelEl.style.fontSize = `${fontSize}px`;
            }

            update(fric, settle, vW, vH, time) {
                // Size interpolation
                this.radius += (this.targetRadius - this.radius) * settle;
                this.mass = this.radius * this.radius;
                
                // Gentle gravity towards center (0,0) to keep the cluster tight
                this.vel.x -= this.pos.x * 0.001;
                this.vel.y -= this.pos.y * 0.001;

                this.pos.add(this.vel); 
                this.vel.multiplyScalar(fric);
                this.material.uniforms.uTime.value = time;
            }

            draw(camera) { 
                // Update WebGL Mesh
                const d = this.radius * 2.6; 
                this.mesh.scale.set(d, d, 1); 
                this.mesh.position.set(this.pos.x, this.pos.y, 0); 
                
                // Update DOM Label projection
                const vector = new THREE.Vector3(this.pos.x, this.pos.y, 0);
                vector.project(camera); // Maps 3D space to -1 to +1 screen space
                
                const screenX = (vector.x * .5 + .5) * window.innerWidth;
                const screenY = -(vector.y * .5 - .5) * window.innerHeight;
                
                this.labelEl.style.transform = `translate(-50%, -50%) translate(${screenX}px, ${screenY}px)`;
            }
        }

        // 2. MAIN APP
        class App {
            constructor() {
                this.config = { 
                    friction: 0.14, 
                    repulsion: 0.65, 
                    settleSpeed: 0.05, 
                    zoomIn: 400, 
                    zoomOut: 1000 
                };
                
                this.blobs = []; 
                this.targetZoom = this.config.zoomIn; 
                this.currentZoom = this.config.zoomIn;
                this.cameraOffset = new THREE.Vector2(0, 0); 
                this.isPanning = false; 

                this.initScene(); 
                this.bindEvents(); 
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera();
                this.camera.position.z = 10;
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                this.labelContainer = document.getElementById('labels-layer');
                
                // Shared materials for performance
                this.baseGeo = new THREE.PlaneGeometry(1, 1);
                this.baseMat = new THREE.ShaderMaterial({
                    uniforms: { uColor: { value: new THREE.Color() }, uSeed: { value: 0 }, uTime: { value: 0 }, uIntensity: { value: 0 } },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    transparent: true, depthTest: false
                });
            }

            // Centralized method for adding/updating words
            addNode(wordString, isTopic) {
                const cleanWord = wordString.trim().toLowerCase();
                if (!cleanWord) return;

                if (wordMap.has(cleanWord)) {
                    // Word exists: increase its weight/size
                    const existingBlob = wordMap.get(cleanWord);
                    existingBlob.addToken();
                    
                    // Add a little physical "bump" to show it was interacted with
                    existingBlob.vel.y += 2;
                } else {
                    // New Word: Spawn it near the center with some randomness
                    const spawnRadius = 50;
                    const angle = Math.random() * Math.PI * 2;
                    const x = Math.cos(angle) * spawnRadius;
                    const y = Math.sin(angle) * spawnRadius;
                    
                    const blob = new Blob(
                        cleanWord, x, y, isTopic, 
                        this.scene, this.baseGeo, this.baseMat, this.labelContainer
                    );
                    
                    this.blobs.push(blob);
                    wordMap.set(cleanWord, blob);
                }
            }

            handleSubmission() {
                const topicInput = document.getElementById('input-topic');
                const w1 = document.getElementById('input-word1');
                const w2 = document.getElementById('input-word2');
                const w3 = document.getElementById('input-word3');

                if(!topicInput.value) { alert("Please enter a topic."); return; }

                // Add the elements to the map
                this.addNode(topicInput.value, true); // True flag = is a Topic
                this.addNode(w1.value, false);
                this.addNode(w2.value, false);
                this.addNode(w3.value, false);

                // Clear inputs for the next entry
                topicInput.value = ''; w1.value = ''; w2.value = ''; w3.value = '';
                topicInput.focus();
            }

            bindEvents() {
                document.getElementById('zoomToggle').onclick = () => {
                    this.targetZoom = (this.targetZoom === this.config.zoomIn) ? this.config.zoomOut : this.config.zoomIn;
                    if(this.targetZoom === this.config.zoomIn) this.cameraOffset.set(0,0);
                };
                
                document.getElementById('btn-submit').onclick = () => this.handleSubmission();
                
                // Allow hitting 'Enter' to submit
                document.getElementById('agora-panel').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.handleSubmission();
                });

                window.addEventListener('mousedown', (e) => {
                    if (e.target.closest('.interactive')) return;
                    if (this.targetZoom === this.config.zoomOut) {
                        this.isPanning = true; this.prevMouse = { x: e.clientX, y: e.clientY };
                    }
                });
                
                window.addEventListener('mousemove', (e) => {
                    if (this.isPanning && this.targetZoom === this.config.zoomOut) {
                        const scalar = this.currentZoom / window.innerHeight;
                        this.cameraOffset.x -= (e.clientX - this.prevMouse.x) * scalar;
                        this.cameraOffset.y += (e.clientY - this.prevMouse.y) * scalar;
                        this.prevMouse = { x: e.clientX, y: e.clientY };
                    }
                });
                
                window.addEventListener('mouseup', () => this.isPanning = false);
                
                window.addEventListener('resize', () => {
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            resolvePhysics() {
                // O(n^2) collision resolution
                for (let i = 0; i < this.blobs.length; i++) {
                    const b1 = this.blobs[i];
                    for (let j = i + 1; j < this.blobs.length; j++) {
                        const b2 = this.blobs[j];
                        const dx = b2.pos.x - b1.pos.x;
                        const dy = b2.pos.y - b1.pos.y;
                        const d2 = dx*dx + dy*dy;
                        const minDist = b1.radius + b2.radius;
                        
                        if (d2 < minDist * minDist) {
                            const d = Math.sqrt(d2) || 0.1;
                            const overlap = (minDist - d) * this.config.repulsion;
                            const nx = dx/d, ny = dy/d, tm = b1.mass + b2.mass;
                            
                            b1.vel.x -= nx * overlap * (b2.mass / tm); 
                            b1.vel.y -= ny * overlap * (b2.mass / tm);
                            b2.vel.x += nx * overlap * (b1.mass / tm); 
                            b2.vel.y += ny * overlap * (b1.mass / tm);
                        }
                    }
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                const time = performance.now() * 0.001;
                this.currentZoom += (this.targetZoom - this.currentZoom) * 0.08;
                const aspect = window.innerWidth / window.innerHeight;
                
                const vW = this.currentZoom * aspect;
                const vH = this.currentZoom;
                
                this.camera.left = -vW/2 + this.cameraOffset.x; 
                this.camera.right = vW/2 + this.cameraOffset.x;
                this.camera.top = vH/2 + this.cameraOffset.y; 
                this.camera.bottom = -vH/2 + this.cameraOffset.y;
                this.camera.updateProjectionMatrix();

                this.blobs.forEach(b => b.update(this.config.friction, this.config.settleSpeed, vW, vH, time));
                this.resolvePhysics();
                
                // Pass camera to draw so labels can track properly
                this.blobs.forEach(b => b.draw(this.camera));

                this.renderer.render(this.scene, this.camera);
            }
        }
        
        window.app = new App();
    </script>
</body>
</html>
