<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaic Fuego - Attention Economy (Debug Mode)</title>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; font-family: sans-serif; }
        canvas { display: block; }
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 100; padding: 20px; color: black; }
        .interactive { pointer-events: auto; }
        
        /* Top Bar for API Controls */
        #api-controls {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(255,255,255,0.95); padding: 10px 20px; border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); align-items: center;
        }
        #api-input { border: 1px solid #ccc; padding: 6px 10px; border-radius: 4px; width: 200px; font-size: 11px; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; background: #ccc; margin-right: 5px; transition: background 0.3s; }
        
        /* Leaderboard & Stats */
        #leaderboard {
            position: absolute; top: 20px; left: 20px;
            width: 220px; background: rgba(255,255,255,0.95); border-radius: 15px; padding: 15px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); font-size: 12px;
        }
        #stats-box { margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid #eee; font-family: monospace; }
        #lb-content { max-height: 40vh; overflow-y: auto; margin: 10px 0; }
        .lb-item { display: flex; justify-content: space-between; padding: 4px 0; cursor: pointer; border-bottom: 1px dotted #eee; }
        .lb-item:hover { font-weight: bold; color: #2196F3; }
        
        .btn {
            background: #222; color: white; border: none; padding: 8px 16px; 
            border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 11px;
            text-transform: uppercase; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.95); }
        .btn-green { background: #2e7d32; }
        
        #zoomToggle { position: absolute; top: 20px; right: 20px; }
        
        /* Message ticker for incoming data */
        #ticker {
            position: absolute; bottom: 20px; left: 20px; right: 20px;
            background: linear-gradient(90deg, transparent, rgba(0,0,0,0.8), transparent);
            color: #0f0; font-family: monospace; padding: 10px; text-align: center;
            font-size: 12px; pointer-events: none; opacity: 0; transition: opacity 0.5s;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="leaderboard" class="interactive">
            <div id="stats-box">
                Active Agents: <span id="agent-count">2000</span><br>
                Token Moves/s: <span id="flow-rate">0</span>
            </div>
            <b style="font-size: 14px;">TOP TRENDS</b>
            <div id="lb-content"></div>
            <button class="btn" id="lb-toggle" style="width:100%; font-size: 9px; margin-top:5px;">Show Full List</button>
        </div>

        <div id="api-controls" class="interactive">
            <div id="connection-dot" class="status-dot"></div>
            <input type="text" id="api-token" placeholder="Paste Mastodon Access Token" id="api-input">
            <button class="btn btn-green" id="btn-connect">Connect Real</button>
            <span style="font-size:10px; opacity:0.5;">OR</span>
            <button class="btn" id="btn-simulate">Simulate Data</button>
        </div>

        <button class="btn interactive" id="zoomToggle">Toggle View</button>
        <div id="ticker">Waiting for data stream...</div>
    </div>
    <div id="container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec2 vUv;
        uniform vec3 uColor;
        uniform float uSeed;
        uniform float uSelected;
        uniform float uTime;
        uniform float uIntensity; // New: visualizes token heat

        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

        void main() {
            vec2 pos = vUv - 0.5;
            float dist = length(pos);
            float angle = atan(pos.y, pos.x);

            // Make spikes more aggressive if the blob has high token intensity
            float spikeAmp = 0.03 + (uIntensity * 0.05); 
            float spikes = sin(angle * (8.0 + mod(uSeed, 4.0)) + uSeed + uTime * uIntensity) * spikeAmp;
            float burst = sin(angle * (12.0 + mod(uSeed, 8.0)) - uSeed) * 0.015;
            
            float edgeDist = 0.41 + spikes + burst;
            float shapeMask = 1.0 - smoothstep(edgeDist, edgeDist + 0.01, dist);
            
            vec2 screenCoord = gl_FragCoord.xy;
            float staticGrain = (random(screenCoord * 0.5) - 0.5) * 0.14;
            
            // Mix color based on intensity (Active topics get brighter/whiter)
            vec3 baseColor = mix(uColor, vec3(1.0, 1.0, 1.0), uIntensity * 0.6);
            vec3 color = mix(baseColor * 1.15, baseColor * 0.85, dist * 1.5) + staticGrain;

            if(uSelected > 0.5) {
                float dots = step(0.5, sin(angle * 20.0 + uTime * 5.0));
                float border = smoothstep(edgeDist - 0.015, edgeDist, dist) * (1.0 - smoothstep(edgeDist, edgeDist + 0.005, dist));
                color = mix(color, vec3(1.0), border * dots);
            }

            gl_FragColor = vec4(color, shapeMask);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // 1. DATA SETUP
        const text = "ai tech privacy security surveillance encryption ethics algorithm digital safety crypto linux opensource software dev webdev coding programming hardware server database cloud infrastructure automation robot robotics cyber cybersec infosec decentralization fediverse mastodon activitypub instance server host admin moderator community moderation censorship freedom rights justice equality equity activism climate sustainability environment green energy nature planet earth space nasa astronomy stars galaxy rocket moon mars planet biology science physics chemistry research academic study university education teaching learning library books reading writing literature poetry art illustration design digitalart photography photo picture video cinema movie animation music sound audio radio podcast stream livestream gaming game player console nintendo deck steam linuxgaming retro arcade coffee tea morning breakfast food cooking recipe delicious healthy gym fitness workout health wellness mentalhealth therapy meditation mindfulness yoga sleep rest history archaeology architecture travel vacation adventure holiday summer winter spring autumn weather rain sun snow wind cloud ocean beach mountain forest plants garden flowers cat caturday kitten dog dogsofmastodon puppy pet animal wildlife bird introduction intro hello welcome news worldpolitics politics election vote democracy government law policy economy finance market money business startup entrepreneur management marketing branding advertisement trend viral breaking announcement update feature release bug fix error problem solution help support guide tutorial documentation clean minimalism simple complex modern classic vintage nostalgia future past present today yesterday tomorrow week month year time life work office remote home desk setup morning night evening weekend friday silentsunday throughthelens sky sunsets clouds gardening flowers blooming vegetables harvest sustainable eco organic zero-waste plasticfree recycling city urban street photography blackandwhite monochrome culture society humanity people person friend family parent child youth age old new small large high low fast slow light dark color red blue green yellow bright dark darkmode accessibility inclusivity diversity community connection conversation reply mention share boost favorite like post thread story blog vlog news media journalism report article essay quote opinion belief debate argument logic reason fact truth reality myth fake scam phishing secure private public local federated global universe space exploration telescope photography landscape portrait wildlife macro aesthetic creative inspiration motivation success goal dream focus productive efficiency tool app mobile desktop phone screen interface user experience pixel vector font typography letter word text language translation speak talk listen hear voice silent noise loud soft hard easy simple difficult challenge progress fail win luck random chaos order pattern harmony balance peace war conflict power leader leadership citizen vote protest movement change reform policy law legal court judge crime police safety danger risk hazard protection defense weapon military peace soldier veteran history memory future vision innovation discovery invention patent science fiction scifi fantasy dragon magic wizard sword shield battle quest adventure roleplay rpg level skill ability power magic mana spell caster heal damage tank support party dungeon loot boss quest craft trade gold silver copper craft artisan maker workshop build construct repair maintenance broken fix update patch version beta alpha release live production stage environment test qa devops deploy pipeline container docker kubernetes cloudflare edge compute backend frontend fullstack api rest graphql webhook latency performance optimize scale cluster distributed consensus p2p torrent magnetic seed peer node network socket protocol handshake secure socket layer tls ssl certificate key token auth login password biometric privacy policy gdpr cookies data tracking analytics metric log dashboard chart graph visualize design ux ui prototype wireframe mockup color palette contrast typography layout grid responsive mobilefirst touch gesture mouse click keyboard shortcut automation macro scripting terminal shell bash vim git commit branch merge pull request push deploy production staging legacy technical debt refactoring clean code solid dry kiss architecture patterns singleton factory observer proxy state strategy memento command visitor iterator template strategy pattern functional programming objectoriented inheritance polymorphism abstraction interface module package dependency manager npm pip cargo gem maven gradle build compile script execution runtime memory heap stack overflow garbage collection pointer reference variable constant scope closure async await promise callback thread process cpu gpu ram storage disk hardware firmware bios kernel os windows macos android ios mobile desktop serverless function lambda worker edge database sql nosql postgres mysql mongo redis graphdb vector search rag llm transformer gpt llama model weights inference training dataset bias hallucination prompt engineering fine-tuning zero-shot few-shot rag embedding cosine similarity vector database nlp natural language processing machine learning deep learning neural network neuron layer weight bias gradient descent backpropagation activation function relu sigmoid loss function accuracy precision recall f1score overfiting training validation test crossvalidation hyperparameter epoch batch latent space diffusion image generation midjourney stable diffusion dall-e synth generative ai creative prompt artist art style brush paint oil watercolor acrylic charcoal sketch pencil ink paper canvas museum gallery exhibition sculpture installation performance videoart film photography portrait landscape nature macro wildlife street architecture city night nightsky milkyway nebula galaxy supernova blackhole lightspeed relativity gravity quantum entanglement particle physics electron proton neutron atom molecule energy power voltage current resistance circuit resistor capacitor inductor transistor semiconductor chip cpu architecture arm x86 risc instruction set assembly compiler linker executable binary hex decimal octal unicode ascii utf8 encoding encryption decryption cipher key publickey privatekey rsa aes sha256 hashing blockchain bitcoin ethereum solana wallet transaction gas fee mining staking validator node consensus proofofwork proofofstake nft smartcontract dapps web3 dao metaverse virtualreality augmentedreality mixedreality xr vr headset controller tracking haptic feedback locomotion immersive presence avatar worldbuilding multiplayer network latency sync lag ping jitter server client p2p authoritative local prediction interpolation extrapolation physics engine collision detection rigidbody softbody fluid simulation particles shader glsl hlsl vertex fragment material texture normalmap bumpmap displacement shadow light ambient diffuse specular reflection refraction transparency glass water skybox fog postprocessing bloom dof motionblur antialiasing raytracing pathtracing rendering rasterization pipe pipeline gpu compute parallel processing multithreading task manager scheduler os kernel filesystem directory file metadata permission owner group read write execute shell environment path alias variable script automation cron job log rotation monitoring alert dashboard metrics uptime downtime maintenance status page incident response postmortem root cause analysis oncall devops sre reliability scalability availability performance tuning load balancer proxy reverse proxy dns domain registrar ssl certificate web server nginx apache caddy serverless edge computing cdn edge side include caching cache invalidation purge headers cookies session storage localstorage indexeddb service worker pwa progressive web app manifest offline mode background sync push notification web socket webrtc real time communication video call voice chat audio conferencing screen sharing collaborative editing version control git github gitlab bitbucket repo branch pull request merge conflict rebase cherrypick stash tag release workflow agile scrum kanban sprint backlog daily standup retrospective planning velocity story points user story requirement specification documentation readme wiki changelog license mit gpl apache bsd creative commons attribution copyleft copyright trademark patent intellectual property open source free software community contribution contributor code of conduct inclusivity diversity equity accessibility screen reader contrast keyboard navigation alt text localization internationalization i18n l10n rtl ltr character set timezone date time format currency units measurement metric imperial conversion logic math arithmetic geometry calculus algebra statistics probability mean median mode deviation variance correlation regression hypothesis testing experiment control group sample size bias significance pvalue data science analytics visualization dashboard kpi metric conversion rate bounce rate retention engagement reach impressions views clicks ctr cpc cpm roi marketing growth hacking seo sem smm content strategy copywriting email marketing newsletter subscription list management segmentation campaign automation landing page lead generation funnel optimization ux ui product design prototyping wireframing testing user research interview survey feedback persona journey map heatmap usability accessibility branding identity logo typography color theory composition layout storytelling narrative theme emotion empathy human-centered design";
        const baseWords = text.split(" ");
        
        // Map allows O(1) lookup from word string to Blob ID
        const wordMap = new Map();

        // 2. BLOB CLASS
        class Blob {
            constructor(id, word, x, y, radius, hue, scene, geo, matBase) {
                this.id = id; 
                this.word = word.split('_')[0]; // Clean word
                this.pos = new THREE.Vector2(x, y);
                this.vel = new THREE.Vector2(0, 0); 
                
                // Token Economy Props
                this.baseRadius = 15;
                this.tokens = 1; // Start with 1 token
                this.targetRadius = this.baseRadius;
                this.radius = this.baseRadius;
                
                this.mass = this.radius * this.radius;
                
                this.material = matBase.clone();
                this.material.uniforms.uColor.value.setHSL(hue/360, 0.65, 0.55);
                this.material.uniforms.uSeed.value = Math.random() * 100.0;
                this.material.uniforms.uTime = { value: 0 };
                this.material.uniforms.uSelected = { value: 0 };
                this.material.uniforms.uIntensity = { value: 0 };

                this.mesh = new THREE.Mesh(geo, this.material);
                this.mesh.userData.parent = this;
                scene.add(this.mesh);
            }
            
            // Called when a user "invests" a token here
            addToken() {
                this.tokens++;
                this.recalcTarget();
            }

            // Called when a user "leaves" for another topic
            removeToken() {
                if(this.tokens > 1) this.tokens--;
                this.recalcTarget();
            }

            recalcTarget() {
                // Area is proportional to tokens. 
                // Formula: Radius = Base * sqrt(tokens)
                // This makes the first few tokens very impactful, but diminishes later (Square Root Law)
                this.targetRadius = this.baseRadius * Math.sqrt(this.tokens * 0.8);
                
                // Visual heat indicator
                this.material.uniforms.uIntensity.value = Math.min(this.tokens / 20.0, 1.0);
            }

            setSelected(state) {
                this.material.uniforms.uSelected.value = state ? 1 : 0;
                this.mesh.renderOrder = state ? 1 : 0;
            }

            update(fric, settle, vW, vH, time) {
                // Smoothly interpolate current radius to target
                this.radius += (this.targetRadius - this.radius) * settle;
                this.mass = this.radius * this.radius;
                
                this.pos.add(this.vel); 
                this.vel.multiplyScalar(fric);
                this.material.uniforms.uTime.value = time;

                // Bounds
                const margin = this.radius * 0.8;
                if (this.pos.x < -vW/2 + margin) this.vel.x += 0.25;
                if (this.pos.x >  vW/2 - margin) this.vel.x -= 0.25;
                if (this.pos.y < -vH/2 + margin) this.vel.y += 0.25;
                if (this.pos.y >  vH/2 - margin) this.vel.y -= 0.25;
            }

            draw() { 
                const d = this.radius * 2.6; 
                this.mesh.scale.set(d, d, 1); 
                this.mesh.position.set(this.pos.x, this.pos.y, 0); 
            }
        }

        // 3. MAIN APP
        class App {
            constructor() {
                this.config = { 
                    count: 750, 
                    agentCount: 2000, // Total Tokens in circulation
                    friction: 0.14, 
                    repulsion: 0.65, 
                    settleSpeed: 0.05, 
                    zoomIn: 480, 
                    zoomOut: 1300 
                };
                
                this.blobs = []; 
                this.agents = []; // Array of ints, where agents[i] = blobID they are watching
                this.tokenMovesPerSec = 0;
                
                this.targetZoom = this.config.zoomIn; 
                this.currentZoom = this.config.zoomIn;
                this.cameraOffset = new THREE.Vector2(0, 0); 
                this.isPanning = false; 
                this.lbFull = false;
                this.selectedBlob = null;
                this.socket = null; // WebSocket holder

                this.initScene(); 
                this.initBlobs(); 
                this.initAgents();
                this.bindEvents(); 
                this.animate();
                
                // Stats ticker
                setInterval(() => {
                    document.getElementById('flow-rate').innerText = this.tokenMovesPerSec;
                    this.tokenMovesPerSec = 0;
                    this.updateUI();
                }, 1000);
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera();
                this.camera.position.z = 10;
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('container').appendChild(this.renderer.domElement);
            }

            initBlobs() {
                const geo = new THREE.PlaneGeometry(1, 1);
                const mat = new THREE.ShaderMaterial({
                    uniforms: { uColor: { value: new THREE.Color() }, uSeed: { value: 0 }, uTime: { value: 0 }, uSelected: { value: 0 }, uIntensity: { value: 0 } },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    transparent: true, depthTest: false
                });
                
                const aspect = window.innerWidth / window.innerHeight;
                const cols = Math.floor(Math.sqrt(this.config.count * aspect));
                const spacing = (this.config.zoomOut * aspect) / cols;
                
                // Generate Blobs
                const uniqueWords = [...new Set(baseWords)]; 
                
                for(let i = 0; i < this.config.count; i++) {
                    const r = Math.floor(i / cols), c = i % cols;
                    const x = (c - cols/2) * spacing + (Math.random()-0.5)*10;
                    const y = (r - (this.config.count/cols)/2) * spacing + (Math.random()-0.5)*10;
                    
                    const word = uniqueWords[i % uniqueWords.length];
                    const blob = new Blob(i, word, x, y, 15, Math.random() * 360, this.scene, geo, mat);
                    
                    this.blobs.push(blob);
                    
                    // Populate Map for O(1) API lookups
                    if (!wordMap.has(word)) wordMap.set(word, []);
                    wordMap.get(word).push(blob);
                }
            }

            initAgents() {
                for(let i=0; i<this.config.agentCount; i++) {
                    const randomBlobIndex = Math.floor(Math.random() * this.blobs.length);
                    this.agents.push(randomBlobIndex);
                    this.blobs[randomBlobIndex].addToken();
                }
            }

            // --- THE CORE LOGIC: MOVING ATTENTION ---
            shiftAttention(targetWord, amountOfAgents) {
                const targets = wordMap.get(targetWord);
                if(!targets) return;

                const targetBlob = targets[0]; 

                for(let k=0; k<amountOfAgents; k++) {
                    const agentIndex = Math.floor(Math.random() * this.agents.length);
                    const oldBlobId = this.agents[agentIndex];

                    if(oldBlobId !== targetBlob.id) {
                        this.blobs[oldBlobId].removeToken();
                        this.agents[agentIndex] = targetBlob.id;
                        targetBlob.addToken();
                        this.tokenMovesPerSec++;
                    }
                }
            }

            // --- MASTODON INTEGRATION (FIXED: Websockets + Debugging) ---
            connectToMastodon(token) {
                console.log("%c Starting Mastodon Connection Sequence...", "color: orange; font-weight:bold;");
                const statusDot = document.getElementById('connection-dot');
                const ticker = document.getElementById('ticker');
                
                if (this.socket) {
                    console.log("Closing previous WebSocket connection...");
                    this.socket.close();
                }

                statusDot.style.background = "orange";
                ticker.style.opacity = 1;
                ticker.innerText = "Connecting via WebSocket...";

                // We use the "public" stream. 
                // NOTE: This can be very fast (firehose).
                const streamUrl = `wss://streaming.mastodon.social/api/v1/streaming?stream=public&access_token=${token}`;
                
                console.log(`Endpoint: wss://streaming.mastodon.social/api/v1/streaming?stream=public&access_token=...[HIDDEN]`);

                try {
                    this.socket = new WebSocket(streamUrl);
                } catch(e) {
                    console.error("FATAL: WebSocket construction failed", e);
                    ticker.innerText = "WebSocket Error (See Console)";
                    statusDot.style.background = "red";
                    return;
                }

                this.socket.onopen = () => {
                    console.log("%c WebSocket Connection ESTABLISHED", "color: green; font-weight:bold;");
                    statusDot.style.background = "#0f0";
                    ticker.innerText = "Connected! Waiting for data...";
                };

                this.socket.onmessage = (event) => {
                    // Debug: Log that we got something (comment out if too noisy)
                    // console.log("Message received, length:", event.data.length);

                    try {
                        const message = JSON.parse(event.data);
                        
                        // Mastodon sends { event: "update", payload: "JSON_STRING" }
                        if (message.event === 'update') {
                            // console.log("Processing 'update' event...");
                            
                            const payload = JSON.parse(message.payload);
                            const content = payload.content; // HTML string
                            
                            // Strip HTML
                            const cleanText = content.replace(/<[^>]*>?/gm, '');
                            const lowerText = cleanText.toLowerCase();

                            // Update Ticker (Throttle visually if needed, but here we update every time)
                            ticker.innerText = `Stream: ${cleanText.substring(0, 80)}...`;

                            // Tokenize
                            const tokens = lowerText.split(/[\s,.]+/);
                            let matches = 0;

                            tokens.forEach(t => {
                                if(wordMap.has(t)) {
                                    // MATCH!
                                    console.log(`%c MATCH FOUND: ${t}`, "color: cyan");
                                    this.shiftAttention(t, 5); // Move 5 agents per mention
                                    matches++;
                                }
                            });
                            
                            if(matches > 0) console.log(`> Shifted attention for ${matches} keywords.`);
                        } 
                        else if (message.event === 'delete') {
                            // console.log("Delete event received (ignoring)");
                        } 
                        else {
                            console.log("Unknown event type:", message.event);
                        }

                    } catch (err) {
                        console.error("Parse Error:", err);
                        console.log("Bad Data:", event.data);
                    }
                };

                this.socket.onerror = (err) => {
                    console.error("WebSocket Error:", err);
                    statusDot.style.background = "red";
                    ticker.innerText = "Connection Error (Check Console)";
                };
                
                this.socket.onclose = (event) => {
                    console.warn(`WebSocket Closed. Code: ${event.code}, Reason: ${event.reason}`);
                     if(statusDot.style.background !== "red") {
                        statusDot.style.background = "orange";
                        ticker.innerText = "Connection Closed.";
                     }
                };
            }

            startSimulation() {
                const ticker = document.getElementById('ticker');
                ticker.style.opacity = 1;
                document.getElementById('connection-dot').style.background = "cyan";
                console.log("Starting Simulation Mode...");
                
                setInterval(() => {
                    const randomBlob = this.blobs[Math.floor(Math.random() * this.blobs.length)];
                    const word = randomBlob.word;
                    ticker.innerText = `Simulated Trend: "${word}" is spiking!`;
                    this.shiftAttention(word, 50);
                }, 200);
            }

            bindEvents() {
                document.getElementById('zoomToggle').onclick = () => {
                    this.targetZoom = (this.targetZoom === this.config.zoomIn) ? this.config.zoomOut : this.config.zoomIn;
                    if(this.targetZoom === this.config.zoomIn) this.cameraOffset.set(0,0);
                };
                document.getElementById('lb-toggle').onclick = () => {
                    this.lbFull = !this.lbFull;
                    document.getElementById('lb-toggle').innerText = this.lbFull ? "Show Top 10" : "Show Full List";
                };
                
                // API Buttons
                document.getElementById('btn-connect').onclick = () => {
                    const token = document.getElementById('api-token').value.trim();
                    if(token) this.connectToMastodon(token);
                    else alert("Please paste a token first!");
                };
                
                document.getElementById('btn-simulate').onclick = () => {
                    this.startSimulation();
                };

                window.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mouseup', () => this.isPanning = false);
                window.addEventListener('resize', () => this.renderer.setSize(window.innerWidth, window.innerHeight));
            }

            selectBlob(blob) {
                if(!blob) return;
                if(this.selectedBlob) this.selectedBlob.setSelected(false);
                this.selectedBlob = blob;
                this.selectedBlob.setSelected(true);
                this.cameraOffset.copy(blob.pos);
            }

            onMouseDown(e) {
                if (e.target.closest('.interactive')) return;
                if (this.targetZoom === this.config.zoomOut) {
                    this.isPanning = true; this.prevMouse = { x: e.clientX, y: e.clientY };
                }
                const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                const ray = new THREE.Raycaster();
                ray.setFromCamera(mouse, this.camera);
                const hits = ray.intersectObjects(this.scene.children);
                if(hits.length > 0) {
                    this.selectBlob(hits[0].object.userData.parent);
                }
            }

            onMouseMove(e) {
                if (this.isPanning && this.targetZoom === this.config.zoomOut) {
                    const scalar = this.currentZoom / window.innerHeight;
                    this.cameraOffset.x -= (e.clientX - this.prevMouse.x) * scalar;
                    this.cameraOffset.y += (e.clientY - this.prevMouse.y) * scalar;
                    this.prevMouse = { x: e.clientX, y: e.clientY };
                }
            }

            resolvePhysics() {
                for (let i = 0; i < this.blobs.length; i++) {
                    const b1 = this.blobs[i];
                    for (let j = i + 1; j < this.blobs.length; j++) {
                        const b2 = this.blobs[j];
                        const dx = b2.pos.x - b1.pos.x, dy = b2.pos.y - b1.pos.y, d2 = dx*dx + dy*dy, min = b1.radius + b2.radius;
                        if (d2 < min * min) {
                            const d = Math.sqrt(d2) || 0.1, overlap = (min - d) * this.config.repulsion;
                            const nx = dx/d, ny = dy/d, tm = b1.mass + b2.mass;
                            b1.vel.x -= nx * overlap * (b2.mass / tm); b1.vel.y -= ny * overlap * (b2.mass / tm);
                            b2.vel.x += nx * overlap * (b1.mass / tm); b2.vel.y += ny * overlap * (b1.mass / tm);
                        }
                    }
                }
            }

            updateUI() {
                const sorted = [...this.blobs].sort((a,b) => b.tokens - a.tokens);
                const list = this.lbFull ? sorted.slice(0, 50) : sorted.slice(0, 10);
                document.getElementById('lb-content').innerHTML = list.map((b) => `
                    <div class="lb-item" onclick="window.app.selectBlob(window.app.blobs[${b.id}])">
                        <span style="${this.selectedBlob?.id === b.id ? 'font-weight:bold; color:#2196F3;' : ''}">${b.word}</span>
                        <span style="opacity:0.5">${b.tokens} ðŸª™</span>
                    </div>
                `).join('');
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const time = performance.now() * 0.001;
                this.currentZoom += (this.targetZoom - this.currentZoom) * 0.08;
                const aspect = window.innerWidth / window.innerHeight;
                const vW = this.currentZoom * aspect, vH = this.currentZoom;
                this.camera.left = -vW/2 + this.cameraOffset.x; this.camera.right = vW/2 + this.cameraOffset.x;
                this.camera.top = vH/2 + this.cameraOffset.y; this.camera.bottom = -vH/2 + this.cameraOffset.y;
                this.camera.updateProjectionMatrix();

                this.blobs.forEach(b => b.update(this.config.friction, this.config.settleSpeed, vW, vH, time));
                this.resolvePhysics();
                this.blobs.forEach(b => b.draw());

                this.renderer.render(this.scene, this.camera);
            }
        }
        window.app = new App();
    </script>
</body>
</html>
