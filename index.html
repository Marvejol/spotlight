<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snappy Mosaic - Fixed & Fast</title>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; font-family: sans-serif; }
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; padding: 20px; color: black; }
        .interactive { pointer-events: auto; }
        
        #search-box {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 5px; background: rgba(255,255,255,0.9); padding: 8px 15px; border-radius: 30px;
        }
        #search-input { border: none; outline: none; background: transparent; width: 200px; }

        #leaderboard {
            position: absolute; top: 20px; left: 20px; width: 200px;
            background: rgba(255,255,255,0.9); padding: 15px; border-radius: 12px; font-size: 12px;
        }
        #lb-content { max-height: 200px; overflow: hidden; margin-bottom: 10px; }
        .lb-item { display: flex; justify-content: space-between; margin-bottom: 3px; cursor: pointer; }
        .lb-item:hover { font-weight: bold; }

        .btn {
            background: white; color: black; border: 1px solid #ccc; padding: 8px 15px; 
            border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 10px;
            text-transform: uppercase; box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        #zoomToggle { position: absolute; top: 20px; right: 20px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="leaderboard" class="interactive">
            <b style="display:block; margin-bottom:10px; border-bottom:1px solid #ddd">TOP BLOBS</b>
            <div id="lb-content"></div>
            <button class="btn" id="lb-toggle" style="width:100%">Show Full List</button>
        </div>

        <div id="search-box" class="interactive">
            <input type="text" id="search-input" placeholder="Search word...">
            <button class="btn" id="search-btn">GO</button>
        </div>

        <button class="btn interactive" id="zoomToggle">Toggle View</button>
    </div>

    <div id="container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec2 vUv;
        uniform vec3 uColor;
        uniform float uSeed;

        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
            vec2 center = vec2(0.5, 0.5);
            vec2 pos = vUv - center;
            float dist = length(pos);
            float angle = atan(pos.y, pos.x);

            float spikes = sin(angle * (8.0 + mod(uSeed, 4.0)) + uSeed) * 0.03;
            float burst = sin(angle * (12.0 + mod(uSeed, 8.0)) - uSeed) * 0.015;
            float shapeMask = 1.0 - smoothstep(0.41 + spikes + burst, 0.42 + spikes + burst, dist);

            vec2 screenCoord = gl_FragCoord.xy;
            float staticGrain = (random(screenCoord * 0.5) - 0.5) * 0.14;

            vec3 gradColor = mix(uColor * 1.15, uColor * 0.85, dist * 1.5);
            gl_FragColor = vec4(gradColor + staticGrain, shapeMask);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const text = "sistema dinamica risposta frequenza stabilità controllo feedback guadagno polo zero smorzamento oscillazione transitorio regime errore algoritmo funzione variabile vettore matrice sensore attuatore segnale filtro rumore analisi progetto sintesi modello simulazione tempo ampiezza fase margine stabilità asintotica sovraelongazione assestamento linearizzazione equilibrio stocastico deterministico campionamento quantizzazione digitale analogico microcontrollore automazione robotica intelligenza convoluzione trasformata laplace fourier z-transform spazio stati osservabilità raggiungibilità compensatore regolatore pid proporzionale integrale derivativo saturazione isteresi ritardo predizione stima filtro kalman identificazione minimi quadrati ottimizzazione vincolo obiettivo costo energia potenza efficienza affidabilità resilienza robustezza incertezza disturbo sensibilità banda passante risonanza picco smorzato naturale forzata libera eccitazione ingresso uscita stato retroazione unità gradino rampa impulso parabolico traiettoria inseguimento riferimento setpoint errore inseguimento precisione accuratezza risoluzione campionatore mantenitore ordine zero primo ricostruzione segnale aliasing nyquist shannon teorema campionamento stabilità ingresso-uscita bibo lyapunov energia dissipativa passività causalità invarianza temporale tempo-variante non lineare caotico frattale rete neurale apprendimento supervisionato rinforzo profondo regressione classificazione clusterizzazione neurone sinapsi peso bias attivazione gradiente backpropagation epoca batch loss optimizer adam sgd dropout normalizzazione regolarizzazione overfitting underfitting validazione cross-validation test set training set iperparametro architettura layer convoluzionale ricorrente trasformatore attenzione encoder decoder sequenza linguaggio naturale visione artificiale elaborazione immagini segmentazione detezione oggetti tracciamento realtà aumentata virtuale mista interfaccia uomo-macchina usabilità accessibilità prototipo sviluppo agile scrum kanban sprint backlog user story testing unitario integrazione sistema accettazione deploy pipeline ci-cd docker kubernetes cloud serverless microservizi api rest graphql database sql nosql transazione acid cap teorema sharding replicazione consistenza disponibilità partizionamento sicurezza crittografia autenticazione autorizzazione token jwt oauth2 ssl tls firewall malware phishing attacco ddos vulnerabilità patch aggiornamento manutenzione documentazione commento codice pulito refactoring debito tecnico architettura esagonale clean architecture solid principi design pattern singleton factory observer strategy decorator adapter proxy bridge facade memento state command iterator visitor template method chain of responsibility mediator flyweight interpreter";
        const baseWords = text.split(" ");
        const values = Array.from({ length: 750 }, (_, i) => `${baseWords[i % baseWords.length]}_${i + 1}`);

        class Blob {
            constructor(id, word, x, y, radius, hue, scene, geo, matBase) {
                this.word = word;
                this.pos = new THREE.Vector2(x, y);
                this.vel = new THREE.Vector2(0, 0);
                this.radius = radius;
                this.targetRadius = radius;
                
                this.material = matBase.clone();
                this.material.uniforms.uColor.value.setHSL(hue/360, 0.6, 0.55);
                this.material.uniforms.uSeed.value = Math.random() * 100;

                this.mesh = new THREE.Mesh(geo, this.material);
                this.mesh.userData.parent = this;
                scene.add(this.mesh);
            }
            update(fric, vW, vH) {
                this.radius += (this.targetRadius - this.radius) * 0.1;
                this.pos.add(this.vel);
                this.vel.multiplyScalar(fric);
                // Borders
                const m = this.radius * 0.8;
                if (this.pos.x < -vW/2 + m) this.vel.x += 0.5;
                if (this.pos.x >  vW/2 - m) this.vel.x -= 0.5;
                if (this.pos.y < -vH/2 + m) this.vel.y += 0.5;
                if (this.pos.y >  vH/2 - m) this.vel.y -= 0.5;
            }
            pop() { this.targetRadius = Math.random() > 0.5 ? Math.min(this.targetRadius + 20, 100) : Math.max(this.targetRadius - 20, 15); }
        }

        class App {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
                this.camera.position.z = 10;
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('container').appendChild(this.renderer.domElement);

                this.zoom = { current: 500, target: 500 };
                this.offset = new THREE.Vector2(0, 0);
                this.blobs = [];
                this.isPanning = false;
                this.lbFull = false;

                this.init();
                this.bind();
                this.animate();
            }

            init() {
                const geo = new THREE.PlaneGeometry(1, 1);
                const mat = new THREE.ShaderMaterial({
                    uniforms: { uColor: { value: new THREE.Color() }, uSeed: { value: 0 } },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    transparent: true, depthTest: false
                });

                const aspect = window.innerWidth / window.innerHeight;
                for(let i=0; i<750; i++) {
                    const x = (Math.random() - 0.5) * 1500;
                    const y = (Math.random() - 0.5) * 1500;
                    this.blobs.push(new Blob(i, values[i], x, y, 20, Math.random()*360, this.scene, geo, mat));
                }
            }

            bind() {
                document.getElementById('zoomToggle').onclick = () => {
                    this.zoom.target = this.zoom.target === 500 ? 1400 : 500;
                    if(this.zoom.target === 500) this.offset.set(0,0);
                };
                document.getElementById('lb-toggle').onclick = () => {
                    this.lbFull = !this.lbFull;
                    document.getElementById('lb-toggle').innerText = this.lbFull ? "Show Top 10" : "Show Full List";
                };
                document.getElementById('search-btn').onclick = () => this.search();
                
                window.addEventListener('mousedown', (e) => {
                    if(e.target.closest('.interactive')) return;
                    if(this.zoom.target > 600) this.isPanning = true;
                    this.checkClick(e);
                });
                window.addEventListener('mousemove', (e) => {
                    if(this.isPanning) {
                        this.offset.x -= e.movementX * (this.zoom.current / window.innerHeight);
                        this.offset.y += e.movementY * (this.zoom.current / window.innerHeight);
                    }
                });
                window.addEventListener('mouseup', () => this.isPanning = false);
                window.addEventListener('resize', () => this.renderer.setSize(window.innerWidth, window.innerHeight));
            }

            search() {
                const val = document.getElementById('search-input').value.toLowerCase();
                const b = this.blobs.find(x => x.word.toLowerCase().includes(val));
                if(b) { this.offset.copy(b.pos); this.zoom.target = 500; b.pop(); }
            }

            checkClick(e) {
                const ray = new THREE.Raycaster();
                const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                ray.setFromCamera(mouse, this.camera);
                const hits = ray.intersectObjects(this.scene.children);
                if(hits.length > 0) hits[0].object.userData.parent.pop();
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.zoom.current += (this.zoom.target - this.zoom.current) * 0.1;
                const aspect = window.innerWidth / window.innerHeight;
                
                this.camera.left = -this.zoom.current * aspect / 2 + this.offset.x;
                this.camera.right = this.zoom.current * aspect / 2 + this.offset.x;
                this.camera.top = this.zoom.current / 2 + this.offset.y;
                this.camera.bottom = -this.zoom.current / 2 + this.offset.y;
                this.camera.updateProjectionMatrix();

                // Physics (Optimized pass)
                const vW = this.zoom.current * aspect * 2, vH = this.zoom.current * 2;
                for(let i=0; i<750; i++) {
                    const b1 = this.blobs[i];
                    b1.update(0.14, vW, vH);
                    for(let j=i+1; j<750; j++) {
                        const b2 = this.blobs[j];
                        const dx = b2.pos.x - b1.pos.x, dy = b2.pos.y - b1.pos.y;
                        const d2 = dx*dx + dy*dy, min = b1.radius + b2.radius;
                        if(d2 < min*min) {
                            const d = Math.sqrt(d2) || 1, overlap = (min - d) * 0.5;
                            const nx = dx/d, ny = dy/d;
                            b1.vel.x -= nx * overlap; b1.vel.y -= ny * overlap;
                            b2.vel.x += nx * overlap; b2.vel.y += ny * overlap;
                        }
                    }
                    b1.draw();
                }

                if(Math.floor(performance.now()) % 1000 < 20) {
                    const sorted = [...this.blobs].sort((a,b)=>b.radius-a.radius).slice(0, this.lbFull?50:10);
                    document.getElementById('lb-content').innerHTML = sorted.map(x => `<div class="lb-item" onclick="window.app.offset.copy(this.pos)">${x.word} <span>${Math.round(x.radius)}</span></div>`).join('');
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        window.app = new App();
    </script>
</body>
</html>
