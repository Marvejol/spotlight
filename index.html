<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotlight Grid</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #ffffff; }
        canvas { display: block; }
    </style>
</head>
<body class="text-neutral-900 font-sans">

    <div class="fixed top-8 left-8 z-10 pointer-events-none select-none">
        <h1 class="text-xs font-bold tracking-widest uppercase opacity-30">Voxel System v1.0</h1>
        <p class="text-2xl font-light tracking-tighter"><span id="credit-count">50</span> <span class="text-sm opacity-40">credits</span></p>
    </div>

    <div id="container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        let credits = 50;
        const gridRes = 100; // 100x100 grid
        const cubes = [];

        // Scene
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        // Camera - High top-down angle
        const camera = new THREE.PerspectiveCamera(30, window.innerWidth / window.innerHeight, 0.1, 2000);
        camera.position.set(40, 150, 40);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('container').appendChild(renderer.domElement);

        // Lighting - Very bright, minimal shadows
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(50, 100, 50);
        scene.add(directionalLight);

        // Grid Generation
        const geometry = new THREE.BoxGeometry(0.95, 1, 0.95);
        // Using a loop for individual control; for performance at 10k+, InstancedMesh is usually better, 
        // but for a simple "one-off" click interaction, this keeps the logic "tight".
        for (let x = 0; x < gridRes; x++) {
            for (let z = 0; z < gridRes; z++) {
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xf5f5f5, 
                    roughness: 0.1 
                });
                const cube = new THREE.Mesh(geometry, material);
                
                cube.position.set(x - gridRes/2, 0, z - gridRes/2);
                scene.add(cube);
                cubes.push(cube);
            }
        }

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.maxPolarAngle = Math.PI / 2.1; // Limit tilt to stay "top-downish"

        // Interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        window.addEventListener('mousedown', (event) => {
            if (credits <= 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cubes);

            if (intersects.length > 0) {
                const clickedCube = intersects[0].object;
                
                // Extrusion Logic
                clickedCube.scale.y += 5; 
                clickedCube.position.y += 2.5; 
                clickedCube.material.color.set(0x000000); // Black pop for feedback
                
                setTimeout(() => {
                    clickedCube.material.color.set(0xe5e5e5);
                }, 150);

                credits--;
                document.getElementById('credit-count').innerText = credits;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
