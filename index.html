<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaic Production Ready - Leaderboard & Pan</title>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        :root {
            --ui-bg: rgba(255, 255, 255, 0.9);
            --text-main: #111;
        }
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; font-family: 'Inter', sans-serif; color: white; }
        canvas { display: block; }

        /* UI Containers */
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; }
        .interactive { pointer-events: auto; }

        #controls { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; }
        
        #leaderboard {
            position: absolute; top: 20px; left: 20px;
            width: 220px; max-height: 80vh;
            background: var(--ui-bg); color: var(--text-main);
            border-radius: 12px; padding: 15px; overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            font-size: 12px; transition: transform 0.3s ease;
        }
        
        #leaderboard h3 { margin: 0 0 10px 0; font-size: 14px; text-transform: uppercase; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
        .lb-item { display: flex; justify-content: space-between; margin-bottom: 4px; font-variant-numeric: tabular-nums; }
        .lb-name { font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 120px; }

        .btn {
            background: white; color: black; border: none; padding: 10px 20px; 
            border-radius: 30px; cursor: pointer; font-weight: bold; 
            font-size: 11px; text-transform: uppercase; letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); transition: all 0.2s;
        }
        .btn:hover { transform: scale(1.05); background: #eee; }
        .btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="leaderboard" class="interactive">
            <h3>Top 50 Blobs</h3>
            <div id="lb-content"></div>
        </div>
        <div id="controls" class="interactive">
            <button class="btn" id="zoomToggle">Toggle View</button>
        </div>
    </div>

    <div id="container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec2 vUv;
        uniform vec3 uColor;
        uniform float uSeed;

        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main() {
            vec2 center = vec2(0.5, 0.5);
            vec2 pos = vUv - center;
            float dist = length(pos);
            float angle = atan(pos.y, pos.x);

            float spikes = sin(angle * (8.0 + mod(uSeed, 4.0)) + uSeed) * 0.03;
            float burst = sin(angle * (12.0 + mod(uSeed, 8.0)) - uSeed) * 0.015;
            float shapeMask = 1.0 - smoothstep(0.41 + spikes + burst, 0.42 + spikes + burst, dist);

            vec2 screenCoord = gl_FragCoord.xy;
            float staticGrain = (random(screenCoord * 0.5) - 0.5) * 0.14;

            vec3 gradColor = mix(uColor * 1.15, uColor * 0.85, dist * 1.5);
            gl_FragColor = vec4(gradColor + staticGrain, shapeMask);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- DATA PREPARATION ---
        const text = "sistema dinamica risposta frequenza stabilità controllo feedback guadagno polo zero smorzamento oscillazione transitorio regime errore algoritmo funzione variabile vettore matrice sensore attuatore segnale filtro rumore analisi progetto sintesi modello simulazione tempo ampiezza fase margine stabilità asintotica sovraelongazione assestamento linearizzazione equilibrio stocastico deterministico campionamento quantizzazione digitale analogico microcontrollore automazione robotica intelligenza convoluzione trasformata laplace fourier z-transform spazio stati osservabilità raggiungibilità compensatore regolatore pid proporzionale integrale derivativo saturazione isteresi ritardo predizione stima filtro kalman identificazione minimi quadrati ottimizzazione vincolo obiettivo costo energia potenza efficienza affidabilità resilienza robustezza incertezza disturbo sensibilità banda passante risonanza picco smorzato naturale forzata libera eccitazione ingresso uscita stato retroazione unità gradino rampa impulso parabolico traiettoria inseguimento riferimento setpoint errore inseguimento precisione accuratezza risoluzione campionatore mantenitore ordine zero primo ricostruzione segnale aliasing nyquist shannon teorema campionamento stabilità ingresso-uscita bibo lyapunov energia dissipativa passività causalità invarianza temporale tempo-variante non lineare caotico frattale rete neurale apprendimento supervisionato rinforzo profondo regressione classificazione clusterizzazione neurone sinapsi peso bias attivazione gradiente backpropagation epoca batch loss optimizer adam sgd dropout normalizzazione regolarizzazione overfitting underfitting validazione cross-validation test set training set iperparametro architettura layer convoluzionale ricorrente trasformatore attenzione encoder decoder sequenza linguaggio naturale visione artificiale elaborazione immagini segmentazione detezione oggetti tracciamento realtà aumentata virtuale mista interfaccia uomo-macchina usabilità accessibilità prototipo sviluppo agile scrum kanban sprint backlog user story testing unitario integrazione sistema accettazione deploy pipeline ci-cd docker kubernetes cloud serverless microservizi api rest graphql database sql nosql transazione acid cap teorema sharding replicazione consistenza disponibilità partizionamento sicurezza crittografia autenticazione autorizzazione token jwt oauth2 ssl tls firewall malware phishing attacco ddos vulnerabilità patch aggiornamento manutenzione documentazione commento codice pulito refactoring debito tecnico architettura esagonale clean architecture solid principi design pattern singleton factory observer strategy decorator adapter proxy bridge facade memento state command iterator visitor template method chain of responsibility mediator flyweight interpreter";
        const baseWords = text.split(" ");
        const values = Array.from({ length: 750 }, (_, i) => `${baseWords[i % baseWords.length]}_${i + 1}`);

        // --- CORE CLASSES ---

        class Blob {
            constructor(id, word, x, y, radius, hue, scene, geometry, materialBase) {
                this.id = id;
                this.word = word;
                this.pos = new THREE.Vector2(x, y);
                this.vel = new THREE.Vector2(0, 0);
                this.radius = radius;
                this.targetRadius = radius;
                this.mass = radius * radius;

                this.material = materialBase.clone();
                this.material.uniforms.uColor.value = new THREE.Color(`hsl(${hue}, 65%, 55%)`);
                this.material.uniforms.uSeed.value = Math.random() * 100;

                this.mesh = new THREE.Mesh(geometry, this.material);
                this.mesh.userData = { parent: this };
                scene.add(this.mesh);
            }

            update(friction, settleSpeed, vW, vH) {
                this.radius += (this.targetRadius - this.radius) * settleSpeed;
                this.mass = this.radius * this.radius;
                this.pos.add(this.vel);
                this.vel.multiplyScalar(friction);

                // Soft Repulsion from edges
                const margin = this.radius * 0.8;
                if (this.pos.x < -vW/2 + margin) this.vel.x += 0.3;
                if (this.pos.x >  vW/2 - margin) this.vel.x -= 0.3;
                if (this.pos.y < -vH/2 + margin) this.vel.y += 0.3;
                if (this.pos.y >  vH/2 - margin) this.vel.y -= 0.3;

                if (this.vel.lengthSq() < 0.0001) this.vel.set(0,0);
            }

            draw() {
                const s = this.radius * 2.6;
                this.mesh.scale.set(s, s, 1);
                this.mesh.position.set(this.pos.x, this.pos.y, 0);
            }
        }

        class MosaicApp {
            constructor() {
                this.config = {
                    count: values.length,
                    zoomIn: 480,
                    zoomOut: 1300,
                    friction: 0.14,
                    repulsion: 0.65,
                    settleSpeed: 0.8
                };

                this.targetZoom = this.config.zoomIn;
                this.currentZoom = this.config.zoomIn;
                this.cameraOffset = new THREE.Vector2(0, 0);
                
                this.isPanning = false;
                this.prevMouse = new THREE.Vector2();

                this.initScene();
                this.initBlobs();
                this.initEvents();
                this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera();
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                document.getElementById('container').appendChild(this.renderer.domElement);
                
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
            }

            initBlobs() {
                const planeGeo = new THREE.PlaneGeometry(1, 1);
                const blobMat = new THREE.ShaderMaterial({
                    uniforms: { uColor: { value: new THREE.Color() }, uSeed: { value: 0 } },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    transparent: true, depthTest: false
                });

                this.blobs = [];
                const aspect = window.innerWidth / window.innerHeight;
                const cols = Math.floor(Math.sqrt(this.config.count * aspect));
                const spacing = (this.config.zoomOut * aspect) / cols;

                values.forEach((word, i) => {
                    const r = Math.floor(i / cols);
                    const c = i % cols;
                    const x = (c - cols/2) * spacing + (Math.random()-0.5)*10;
                    const y = (r - (this.config.count/cols)/2) * spacing + (Math.random()-0.5)*10;
                    
                    this.blobs.push(new Blob(i, word, x, y, 18, Math.random() * 360, this.scene, planeGeo, blobMat));
                });
            }

            initEvents() {
                window.addEventListener('resize', () => this.onResize());
                document.getElementById('zoomToggle').addEventListener('click', () => {
                    this.targetZoom = (this.targetZoom === this.config.zoomIn) ? this.config.zoomOut : this.config.zoomIn;
                    if (this.targetZoom === this.config.zoomIn) this.cameraOffset.set(0, 0);
                });

                window.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mouseup', () => this.isPanning = false);
            }

            onMouseDown(e) {
                if (e.target.closest('.interactive')) return;
                
                // Detection for Pop
                this.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                this.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                // Se siamo in zoom out, attiviamo il pan
                if (this.targetZoom === this.config.zoomOut) {
                    this.isPanning = true;
                    this.prevMouse.set(e.clientX, e.clientY);
                }

                this.raycaster.setFromCamera(this.mouse, this.camera);
                const hits = this.raycaster.intersectObjects(this.scene.children);
                if (hits.length > 0) hits[0].object.userData.parent.pop();
            }

            onMouseMove(e) {
                if (this.isPanning && this.targetZoom === this.config.zoomOut) {
                    const dx = (e.clientX - this.prevMouse.x) * (this.currentZoom / window.innerHeight);
                    const dy = (e.clientY - this.prevMouse.y) * (this.currentZoom / window.innerHeight);
                    this.cameraOffset.x -= dx;
                    this.cameraOffset.y += dy;
                    this.prevMouse.set(e.clientX, e.clientY);
                }
            }

            onResize() {
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }

            resolvePhysics() {
                for (let i = 0; i < this.blobs.length; i++) {
                    const b1 = this.blobs[i];
                    for (let j = i + 1; j < this.blobs.length; j++) {
                        const b2 = this.blobs[j];
                        const dx = b2.pos.x - b1.pos.x;
                        const dy = b2.pos.y - b1.pos.y;
                        const distSq = dx*dx + dy*dy;
                        const minD = b1.radius + b2.radius;
                        if (distSq < minD * minD) {
                            const dist = Math.sqrt(distSq) || 0.1;
                            const overlap = (minD - dist) * this.config.repulsion;
                            const nx = dx/dist, ny = dy/dist;
                            const tm = b1.mass + b2.mass;
                            b1.vel.x -= nx * overlap * (b2.mass / tm);
                            b1.vel.y -= ny * overlap * (b2.mass / tm);
                            b2.vel.x += nx * overlap * (b1.mass / tm);
                            b2.vel.y += ny * overlap * (b1.mass / tm);
                        }
                    }
                }
            }

            updateUI() {
                const top50 = [...this.blobs]
                    .sort((a, b) => b.radius - a.radius)
                    .slice(0, 50);

                const html = top50.map((b, i) => `
                    <div class="lb-item">
                        <span>${i+1}. <span class="lb-name">${b.word}</span></span>
                        <span>${Math.round(b.radius)}</span>
                    </div>
                `).join('');
                document.getElementById('lb-content').innerHTML = html;
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                this.currentZoom += (this.targetZoom - this.currentZoom) * 0.08;
                const aspect = window.innerWidth / window.innerHeight;
                const vW = this.currentZoom * aspect;
                const vH = this.currentZoom;

                // Update Camera
                this.camera.left = -vW/2 + this.cameraOffset.x;
                this.camera.right = vW/2 + this.cameraOffset.x;
                this.camera.top = vH/2 + this.cameraOffset.y;
                this.camera.bottom = -vH/2 + this.cameraOffset.y;
                this.camera.updateProjectionMatrix();

                // Logic
                this.blobs.forEach(b => b.update(this.config.friction, this.config.settleSpeed, vW * 2, vH * 2));
                this.resolvePhysics();
                this.blobs.forEach(b => b.draw());

                if (Math.random() < 0.01) this.blobs[Math.floor(Math.random()*this.blobs.length)].pop();
                if (Math.floor(performance.now() / 500) % 2 === 0) this.updateUI(); // Throttle UI update

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start App
        new MosaicApp();
    </script>
</body>
</html>
