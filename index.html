<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mosaic Fuego - Exponential Selection</title>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; font-family: sans-serif; }
        canvas { display: block; }
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 100; padding: 20px; color: black; }
        .interactive { pointer-events: auto; }
        #search-box {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 8px; background: rgba(255,255,255,0.95); padding: 8px 15px; border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        #search-input { border: none; outline: none; background: transparent; width: 180px; font-weight: bold; }
        #leaderboard {
            width: 220px; background: rgba(255,255,255,0.95); border-radius: 15px; padding: 15px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); font-size: 12px;
        }
        #lb-content { max-height: 50vh; overflow-y: auto; margin: 10px 0; border-top: 1px solid #eee; }
        .lb-item { display: flex; justify-content: space-between; padding: 4px 0; cursor: pointer; }
        .lb-item:hover { font-weight: bold; color: #000; }
        .btn {
            background: white; color: black; border: none; padding: 10px 18px; 
            border-radius: 20px; cursor: pointer; font-weight: bold; font-size: 11px;
            text-transform: uppercase; box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        #zoomToggle { position: absolute; top: 20px; right: 20px; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="leaderboard" class="interactive">
            <b style="font-size: 14px;">TOP BLOBS</b>
            <div id="lb-content"></div>
            <button class="btn" id="lb-toggle" style="width:100%; font-size: 9px;">Show Full List</button>
        </div>
        <div id="search-box" class="interactive">
            <input type="text" id="search-input" placeholder="Cerca parola...">
            <button class="btn" id="search-go" style="padding: 5px 12px;">GO</button>
        </div>
        <button class="btn interactive" id="zoomToggle">Toggle View</button>
    </div>
    <div id="container"></div>

    <script type="x-shader/x-vertex" id="vertexshader">
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>

    <script type="x-shader/x-fragment" id="fragmentshader">
        varying vec2 vUv;
        uniform vec3 uColor;
        uniform float uSeed;
        uniform float uSelected;
        uniform float uTime;

        float random(vec2 st) { return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123); }

        void main() {
            vec2 pos = vUv - 0.5;
            float dist = length(pos);
            float angle = atan(pos.y, pos.x);

            float spikes = sin(angle * (8.0 + mod(uSeed, 4.0)) + uSeed) * 0.03;
            float burst = sin(angle * (12.0 + mod(uSeed, 8.0)) - uSeed) * 0.015;
            
            float edgeDist = 0.41 + spikes + burst;
            float shapeMask = 1.0 - smoothstep(edgeDist, edgeDist + 0.01, dist);
            
            vec2 screenCoord = gl_FragCoord.xy;
            float staticGrain = (random(screenCoord * 0.5) - 0.5) * 0.14;
            vec3 color = mix(uColor * 1.15, uColor * 0.85, dist * 1.5) + staticGrain;

            if(uSelected > 0.5) {
                float dots = step(0.5, sin(angle * 20.0 + uTime * 5.0));
                float border = smoothstep(edgeDist - 0.015, edgeDist, dist) * (1.0 - smoothstep(edgeDist, edgeDist + 0.005, dist));
                color = mix(color, vec3(1.0), border * dots);
            }

            gl_FragColor = vec4(color, shapeMask);
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const text = "sistema dinamica risposta frequenza stabilità controllo feedback guadagno polo zero smorzamento oscillazione transitorio regime errore algoritmo funzione variabile vettore matrice sensore attuatore segnale filtro rumore analisi progetto sintesi modello simulazione tempo ampiezza fase margine stabilità asintotica sovraelongazione assestamento linearizzazione equilibrio stocastico deterministico campionamento quantizzazione digitale analogico microcontrollore automazione robotica intelligenza convoluzione trasformata laplace fourier z-transform spazio stati osservabilità raggiungibilità compensatore regolatore pid proporzionale integrale derivativo saturazione isteresi ritardo predizione stima filtro kalman identificazione minimi quadrati ottimizzazione vincolo obiettivo costo energia potenza efficienza affidabilità resilienza robustezza incertezza disturbo sensibilità banda passante risonanza picco smorzato naturale forzata libera eccitazione ingresso uscita stato retroazione unità gradino rampa impulso parabolico traiettoria inseguimento riferimento setpoint errore inseguimento precisione accuratezza risoluzione campionatore mantenitore ordine zero primo ricostruzione segnale aliasing nyquist shannon teorema campionamento stabilità ingresso-uscita bibo lyapunov energia dissipativa passività causalità invarianza temporale tempo-variante non lineare caotico frattale rete neurale apprendimento supervisionato rinforzo profondo regressione classificazione clusterizzazione neurone sinapsi peso bias attivazione gradiente backpropagation epoca batch loss optimizer adam sgd dropout normalizzazione regolarizzazione overfitting underfitting validazione cross-validation test set training set iperparametro architettura layer convoluzionale ricorrente trasformatore attenzione encoder decoder sequenza linguaggio naturale visione artificiale elaborazione immagini segmentazione detezione oggetti tracciamento realtà aumentata virtuale mista interfaccia uomo-macchina usabilità accessibilità prototipo sviluppo agile scrum kanban sprint backlog user story testing unitario integrazione sistema accettazione deploy pipeline ci-cd docker kubernetes cloud serverless microservizi api rest graphql database sql nosql transazione acid cap teorema sharding replicazione consistenza disponibilità partizionamento sicurezza crittografia autenticazione autorizzazione token jwt oauth2 ssl tls firewall malware phishing attacco ddos vulnerabilità patch aggiornamento manutenzione documentazione commento codice pulito refactoring debito tecnico architettura esagonale clean architecture solid principi design pattern singleton factory observer strategy decorator adapter proxy bridge facade memento state command iterator visitor template method chain of responsibility mediator flyweight interpreter";
        const baseWords = text.split(" ");
        const words = Array.from({ length: 750 }, (_, i) => `${baseWords[i % baseWords.length]}_${i + 1}`);

        class Blob {
            constructor(id, word, x, y, radius, hue, scene, geo, matBase) {
                this.id = id; this.word = word; this.pos = new THREE.Vector2(x, y);
                this.vel = new THREE.Vector2(0, 0); this.radius = radius; this.targetRadius = radius;
                this.mass = radius * radius;
                this.growthFactor = 1.0; // New: Exponential decay starts at 1
                this.material = matBase.clone();
                this.material.uniforms.uColor.value.setHSL(hue/360, 0.65, 0.55);
                this.material.uniforms.uSeed.value = Math.random() * 100.0;
                this.material.uniforms.uTime = { value: 0 };
                this.material.uniforms.uSelected = { value: 0 };

                this.mesh = new THREE.Mesh(geo, this.material);
                this.mesh.userData.parent = this;
                scene.add(this.mesh);
            }
            setSelected(state) {
                this.material.uniforms.uSelected.value = state ? 1 : 0;
                this.mesh.renderOrder = state ? 1 : 0;
            }
            update(fric, settle, vW, vH, time) {
                this.radius += (this.targetRadius - this.radius) * settle;
                this.mass = this.radius * this.radius;
                this.pos.add(this.vel); this.vel.multiplyScalar(fric);
                this.material.uniforms.uTime.value = time;

                const margin = this.radius * 0.8;
                if (this.pos.x < -vW/2 + margin) this.vel.x += 0.25;
                if (this.pos.x >  vW/2 - margin) this.vel.x -= 0.25;
                if (this.pos.y < -vH/2 + margin) this.vel.y += 0.25;
                if (this.pos.y >  vH/2 - margin) this.vel.y -= 0.25;
                if (this.vel.lengthSq() < 0.0001) this.vel.set(0,0);
            }
            pop() {
                // Logic: Change is multiplied by growthFactor, then factor is halved (exponential decay)
                const baseChange = Math.random() * 80 + 20; 
                const dir = Math.random() > 0.5 ? 1 : -1;
                
                this.targetRadius = THREE.MathUtils.clamp(this.targetRadius + (baseChange * this.growthFactor * dir), 10, 160);
                
                this.growthFactor *= 0.5; // Exponential reduction
                
                // Periodically reset factor so they don't stop forever
                if(this.growthFactor < 0.01 && Math.random() < 0.05) this.growthFactor = 1.0;
            }
            draw() { const d = this.radius * 2.6; this.mesh.scale.set(d, d, 1); this.mesh.position.set(this.pos.x, this.pos.y, 0); }
        }

        class App {
            constructor() {
                this.config = { count: 750, friction: 0.14, repulsion: 0.65, settleSpeed: 0.8, zoomIn: 480, zoomOut: 1300 };
                this.blobs = []; this.targetZoom = this.config.zoomIn; this.currentZoom = this.config.zoomIn;
                this.cameraOffset = new THREE.Vector2(0, 0); this.isPanning = false; this.lbFull = false;
                this.selectedBlob = null;

                this.initScene(); this.initBlobs(); this.bindEvents(); this.animate();
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.OrthographicCamera();
                this.camera.position.z = 10;
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('container').appendChild(this.renderer.domElement);
            }

            initBlobs() {
                const geo = new THREE.PlaneGeometry(1, 1);
                const mat = new THREE.ShaderMaterial({
                    uniforms: { uColor: { value: new THREE.Color() }, uSeed: { value: 0 }, uTime: { value: 0 }, uSelected: { value: 0 } },
                    vertexShader: document.getElementById('vertexshader').textContent,
                    fragmentShader: document.getElementById('fragmentshader').textContent,
                    transparent: true, depthTest: false
                });
                const aspect = window.innerWidth / window.innerHeight;
                const cols = Math.floor(Math.sqrt(this.config.count * aspect));
                const spacing = (this.config.zoomOut * aspect) / cols;
                for(let i = 0; i < this.config.count; i++) {
                    const r = Math.floor(i / cols), c = i % cols;
                    const x = (c - cols/2) * spacing + (Math.random()-0.5)*10;
                    const y = (r - (this.config.count/cols)/2) * spacing + (Math.random()-0.5)*10;
                    this.blobs.push(new Blob(i, words[i], x, y, 18, Math.random() * 360, this.scene, geo, mat));
                }
            }

            bindEvents() {
                document.getElementById('zoomToggle').onclick = () => {
                    this.targetZoom = (this.targetZoom === this.config.zoomIn) ? this.config.zoomOut : this.config.zoomIn;
                    if(this.targetZoom === this.config.zoomIn) this.cameraOffset.set(0,0);
                };
                document.getElementById('lb-toggle').onclick = () => {
                    this.lbFull = !this.lbFull;
                    document.getElementById('lb-toggle').innerText = this.lbFull ? "Show Top 10" : "Show Full List";
                };
                document.getElementById('search-go').onclick = () => this.search();
                document.getElementById('search-input').onkeydown = (e) => { if(e.key === "Enter") this.search(); };
                window.addEventListener('mousedown', (e) => this.onMouseDown(e));
                window.addEventListener('mousemove', (e) => this.onMouseMove(e));
                window.addEventListener('mouseup', () => this.isPanning = false);
                window.addEventListener('resize', () => this.renderer.setSize(window.innerWidth, window.innerHeight));
            }

            selectBlob(blob) {
                if(!blob) return;
                if(this.selectedBlob) this.selectedBlob.setSelected(false);
                this.selectedBlob = blob;
                this.selectedBlob.setSelected(true);
                this.cameraOffset.copy(blob.pos);
            }

            search() {
                const q = document.getElementById('search-input').value.toLowerCase();
                const b = this.blobs.find(x => x.word.toLowerCase() === q || x.word.toLowerCase().includes(q));
                this.selectBlob(b);
            }

            onMouseDown(e) {
                if (e.target.closest('.interactive')) return;
                if (this.targetZoom === this.config.zoomOut) {
                    this.isPanning = true; this.prevMouse = { x: e.clientX, y: e.clientY };
                }
                const mouse = new THREE.Vector2((e.clientX/window.innerWidth)*2-1, -(e.clientY/window.innerHeight)*2+1);
                const ray = new THREE.Raycaster();
                ray.setFromCamera(mouse, this.camera);
                const hits = ray.intersectObjects(this.scene.children);
                if(hits.length > 0) {
                    this.selectBlob(hits[0].object.userData.parent);
                } else {
                    if(this.selectedBlob) this.selectedBlob.setSelected(false);
                    this.selectedBlob = null;
                }
            }

            onMouseMove(e) {
                if (this.isPanning && this.targetZoom === this.config.zoomOut) {
                    const scalar = this.currentZoom / window.innerHeight;
                    this.cameraOffset.x -= (e.clientX - this.prevMouse.x) * scalar;
                    this.cameraOffset.y += (e.clientY - this.prevMouse.y) * scalar;
                    this.prevMouse = { x: e.clientX, y: e.clientY };
                }
            }

            resolvePhysics() {
                for (let i = 0; i < this.blobs.length; i++) {
                    const b1 = this.blobs[i];
                    for (let j = i + 1; j < this.blobs.length; j++) {
                        const b2 = this.blobs[j];
                        const dx = b2.pos.x - b1.pos.x, dy = b2.pos.y - b1.pos.y, d2 = dx*dx + dy*dy, min = b1.radius + b2.radius;
                        if (d2 < min * min) {
                            const d = Math.sqrt(d2) || 0.1, overlap = (min - d) * this.config.repulsion;
                            const nx = dx/d, ny = dy/d, tm = b1.mass + b2.mass;
                            b1.vel.x -= nx * overlap * (b2.mass / tm); b1.vel.y -= ny * overlap * (b2.mass / tm);
                            b2.vel.x += nx * overlap * (b1.mass / tm); b2.vel.y += ny * overlap * (b1.mass / tm);
                        }
                    }
                }
            }

            updateUI() {
                const sorted = [...this.blobs].sort((a,b) => b.radius - a.radius);
                const list = this.lbFull ? sorted.slice(0, 50) : sorted.slice(0, 10);
                document.getElementById('lb-content').innerHTML = list.map((b) => `
                    <div class="lb-item" onclick="window.app.selectBlob(window.app.blobs[${b.id}])">
                        <span style="${this.selectedBlob?.id === b.id ? 'font-weight:bold; color:#2196F3;' : ''}">${b.word.split('_')[0]}</span>
                        <span style="opacity:0.5">${Math.round(b.radius)}</span>
                    </div>
                `).join('');
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                const time = performance.now() * 0.001;
                this.currentZoom += (this.targetZoom - this.currentZoom) * 0.08;
                const aspect = window.innerWidth / window.innerHeight;
                const vW = this.currentZoom * aspect, vH = this.currentZoom;
                this.camera.left = -vW/2 + this.cameraOffset.x; this.camera.right = vW/2 + this.cameraOffset.x;
                this.camera.top = vH/2 + this.cameraOffset.y; this.camera.bottom = -vH/2 + this.cameraOffset.y;
                this.camera.updateProjectionMatrix();

                this.blobs.forEach(b => b.update(this.config.friction, this.config.settleSpeed, vW, vH, time));
                this.resolvePhysics();
                this.blobs.forEach(b => b.draw());

                // Trigger 2 random pops every frame to keep the field dynamic
                for(let k = 0; k < 2; k++) {
                    this.blobs[Math.floor(Math.random() * this.config.count)].pop();
                }

                if(Math.floor(performance.now() / 1000) % 2 === 0) this.updateUI();
                this.renderer.render(this.scene, this.camera);
            }
        }
        window.app = new App();
    </script>
</body>
</html>
